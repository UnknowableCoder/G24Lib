<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>G24Lib: g24_lib Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">G24Lib
   </div>
   <div id="projectbrief">A set of convenient classes, functions and other utilities mainly for quickly writing numerical code. Provides relatively easy integration with CUDA, general Runge-Kutta methods, linear equation solvers and more.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceg24__lib.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">g24_lib Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The namespace where all the library resides.  
<a href="namespaceg24__lib.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceg24__lib_1_1_c_u_d_a__kernel__size"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceg24__lib_1_1_c_u_d_a__kernel__size.html">CUDA_kernel_size</a></td></tr>
<tr class="memdesc:namespaceg24__lib_1_1_c_u_d_a__kernel__size"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds definitions that generalize estimation of <code>CUDA</code> kernel sizes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceg24__lib_1_1exceptions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceg24__lib_1_1exceptions.html">exceptions</a></td></tr>
<tr class="memdesc:namespaceg24__lib_1_1exceptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds our custom exception objects to allow for interoperatability with <code>CUDA</code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceg24__lib_1_1internals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceg24__lib_1_1internals.html">internals</a></td></tr>
<tr class="memdesc:namespaceg24__lib_1_1internals"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace where several implementation details are stored. When possibly relevant, they are documented here, but, being implementation details, they should not be used by the end users! <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceg24__lib_1_1_memory_context"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceg24__lib_1_1_memory_context.html">MemoryContext</a></td></tr>
<tr class="memdesc:namespaceg24__lib_1_1_memory_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different memory contexts supported by the library are here. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceg24__lib_1_1_non_matrix_linear_solvers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceg24__lib_1_1_non_matrix_linear_solvers.html">NonMatrixLinearSolvers</a></td></tr>
<tr class="memdesc:namespaceg24__lib_1_1_non_matrix_linear_solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds linear equation solvers that forego the creation of (sparse) matrices when the components of <code>A x</code> and <code>b</code> can be more easily expressed with functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceg24__lib_1_1_parallelism"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceg24__lib_1_1_parallelism.html">Parallelism</a></td></tr>
<tr class="memdesc:namespaceg24__lib_1_1_parallelism"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different forms of parallelism supported by the library are here. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceg24__lib_1_1_runge_kutta_methods"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceg24__lib_1_1_runge_kutta_methods.html">RungeKuttaMethods</a></td></tr>
<tr class="memdesc:namespaceg24__lib_1_1_runge_kutta_methods"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds Runge-Kutta Methods for use with <code><a class="el" href="classg24__lib_1_1temporal__evolver.html" title="Evolves a function in time according to the Runge-Kutta method specified by butcher_tableau.">g24_lib::temporal_evolver</a></code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceg24__lib_1_1view"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceg24__lib_1_1view.html">view</a></td></tr>
<tr class="memdesc:namespaceg24__lib_1_1view"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds several tag-like classes to allow selection of ranges instead of single elements using <code>g24_lib::ndview::operator[]</code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classg24__lib_1_1carried__bool__vector.html">carried_bool_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that holds an array of booleans in a given memory context in a space efficient way, by packing them as the binary representation of another object.  <a href="classg24__lib_1_1carried__bool__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1class__info.html">class_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a limited form of compile time reflection.  <a href="structg24__lib_1_1class__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classg24__lib_1_1coll.html">coll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a run-time defined number of objects in a run-time defined number of dimensions.  <a href="classg24__lib_1_1coll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classg24__lib_1_1comp.html">comp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A complex number.  <a href="classg24__lib_1_1comp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1constexpr__fraction.html">constexpr_fraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>constexpr</code> way of holding a compile time fraction.  <a href="structg24__lib_1_1constexpr__fraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages memory on a CUDA-enabled GPU.  <a href="structg24__lib_1_1_c_u_d_a__memory__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1default__memory__manager.html">default_memory_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages memory on the CPU. Basically a slightly different take on <code>std::allocator</code>...  <a href="structg24__lib_1_1default__memory__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1_definitions.html">Definitions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the definitions of the library, which can be changed by declaring the relevant members in a class <code>g24_lib::Configuration</code>.  <a href="structg24__lib_1_1_definitions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classg24__lib_1_1derivator.html">derivator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 1D differential operation of order <code>ord</code> weighted by <code>npoints</code>.  <a href="classg24__lib_1_1derivator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1dummy__function.html">dummy_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a generic, dummy function, mainly for template parameters that need a function when we don't quite have one.  <a href="structg24__lib_1_1dummy__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1dummy__void__function.html">dummy_void_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a generic, dummy void function, mainly for template parameters that need a function when we don't quite have one.  <a href="structg24__lib_1_1dummy__void__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1empty__array.html">empty_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mock array with default-constructed elements of type <code>Type</code>.  <a href="structg24__lib_1_1empty__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1fixed__return__array.html">fixed_return_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mock array with a fixed return value.  <a href="structg24__lib_1_1fixed__return__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1flat__imitation__struct.html">flat_imitation_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a struct that has every scalar member of all the members of a class (at all levels of inclusion) based on compile time reflection from <code><a class="el" href="structg24__lib_1_1class__info.html" title="Provides a limited form of compile time reflection.">g24_lib::class_info</a></code>.  <a href="structg24__lib_1_1flat__imitation__struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1fraction.html">fraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a fraction with numerator and denominator of type <code>factorT</code>.  <a href="structg24__lib_1_1fraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classg24__lib_1_1fspoint.html">fspoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of <code>Size</code> elements of type <code>Type</code>. Mainly to be used as an N-dimensional vector in mathematical or physical contexts.  <a href="classg24__lib_1_1fspoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1identity__functor.html">identity_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that acts as an identity function.  <a href="structg24__lib_1_1identity__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classg24__lib_1_1managed__object.html">managed_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that holds an object in a given memory context.  <a href="classg24__lib_1_1managed__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1memory__manager__base.html">memory_manager_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a base class for all memory managers.  <a href="structg24__lib_1_1memory__manager__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classg24__lib_1_1ndview.html">ndview</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows indexing of multidimensional arrays.  <a href="classg24__lib_1_1ndview.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1nested__imitation__struct.html">nested_imitation_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a struct that has the members of a class based on compile time reflection from <code><a class="el" href="structg24__lib_1_1class__info.html" title="Provides a limited form of compile time reflection.">g24_lib::class_info</a></code>.  <a href="structg24__lib_1_1nested__imitation__struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1operation__array.html">operation_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mock array with its return value being calculated at each point.  <a href="structg24__lib_1_1operation__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classg24__lib_1_1point.html">point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamically sized array of type <code>Type</code>. Mainly to be used as an N-dimensional vector in mathematical or physical contexts.  <a href="classg24__lib_1_1point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1return__ith__functor.html">return_ith_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that acts as an <code>operator[]</code>.  <a href="structg24__lib_1_1return__ith__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1set__ith__functor.html">set_ith_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that sets each element to a provided value.  <a href="structg24__lib_1_1set__ith__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classg24__lib_1_1simple__array.html">simple_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that holds an array of objects in a given memory context.  <a href="classg24__lib_1_1simple__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1simple__evolve__result.html">simple_evolve_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The results of a <code><a class="el" href="namespaceg24__lib.html#aedf046e132ed3d55b828a64d6011f359" title="Provides a simpler wrapper for g24_lib::temporal_evolver for objects that are known to be simple to u...">g24_lib::simple_evolve</a></code>.  <a href="structg24__lib_1_1simple__evolve__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1split__member__array.html">split_member_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that stores the different members of a struct that can undergo compile time reflection through <code><a class="el" href="structg24__lib_1_1class__info.html" title="Provides a limited form of compile time reflection.">g24_lib::class_info</a></code> as separate arrays. In short, translates an <em>array of structs</em> into a <em>struct of arrays</em> in a more or less automatic way.  <a href="structg24__lib_1_1split__member__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classg24__lib_1_1temporal__evolver.html">temporal_evolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evolves a function in time according to the Runge-Kutta method specified by <code>butcher_tableau</code>.  <a href="classg24__lib_1_1temporal__evolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1value__padded__array.html">value_padded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container padded with a fixed value after a specified size.  <a href="structg24__lib_1_1value__padded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structg24__lib_1_1wildcard.html">wildcard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class with the amazing ability to convert to any type.  <a href="structg24__lib_1_1wildcard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af2a860556619930385d178a47672fd6b"><td class="memTemplParams" colspan="2">template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:af2a860556619930385d178a47672fd6b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#af2a860556619930385d178a47672fd6b">array</a> = <a class="el" href="classg24__lib_1_1simple__array.html">simple_array</a>&lt; Type, num, <a class="el" href="namespaceg24__lib_1_1_memory_context.html#ad7443412ad1c5a53abdc4b78e94231c3">MemoryContext::current_manager</a>&lt; Type, num &gt;, true &gt;</td></tr>
<tr class="memdesc:af2a860556619930385d178a47672fd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classg24__lib_1_1simple__array.html" title="A container that holds an array of objects in a given memory context.">g24_lib::simple_array</a></code> that holds the array in the memory appropriate for the current context.  <a href="namespaceg24__lib.html#af2a860556619930385d178a47672fd6b">More...</a><br /></td></tr>
<tr class="separator:af2a860556619930385d178a47672fd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c56203165aa91296a62a7df111105a"><td class="memTemplParams" colspan="2">template&lt;class parallel , class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a01c56203165aa91296a62a7df111105a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a01c56203165aa91296a62a7df111105a">array_parallel</a> = <a class="el" href="classg24__lib_1_1simple__array.html">simple_array</a>&lt; Type, num, typename parallel::template memory_manager&lt; Type, num &gt;, true &gt;</td></tr>
<tr class="memdesc:a01c56203165aa91296a62a7df111105a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classg24__lib_1_1simple__array.html" title="A container that holds an array of objects in a given memory context.">g24_lib::simple_array</a></code> that holds the array in a way that is appropriate for a specific type of parallelism.  <a href="namespaceg24__lib.html#a01c56203165aa91296a62a7df111105a">More...</a><br /></td></tr>
<tr class="separator:a01c56203165aa91296a62a7df111105a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397806504e77306f3ad9a7229e3a0f5c"><td class="memTemplParams" colspan="2">template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a397806504e77306f3ad9a7229e3a0f5c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a397806504e77306f3ad9a7229e3a0f5c">bool_vector</a> = <a class="el" href="classg24__lib_1_1carried__bool__vector.html">carried_bool_vector</a>&lt; Type, indexer, <a class="el" href="namespaceg24__lib_1_1_memory_context.html#ad7443412ad1c5a53abdc4b78e94231c3">MemoryContext::current_manager</a>&lt; Type, indexer &gt;, true &gt;</td></tr>
<tr class="memdesc:a397806504e77306f3ad9a7229e3a0f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classg24__lib_1_1carried__bool__vector.html" title="A container that holds an array of booleans in a given memory context in a space efficient way,...">g24_lib::carried_bool_vector</a></code> that holds the booleans in the memory appropriate for the current context.  <a href="namespaceg24__lib.html#a397806504e77306f3ad9a7229e3a0f5c">More...</a><br /></td></tr>
<tr class="separator:a397806504e77306f3ad9a7229e3a0f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648ed7276ad4a6e9e7a049a4e9358037"><td class="memTemplParams" colspan="2">template&lt;class parallel , class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a648ed7276ad4a6e9e7a049a4e9358037"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a648ed7276ad4a6e9e7a049a4e9358037">bool_vector_parallel</a> = <a class="el" href="classg24__lib_1_1carried__bool__vector.html">carried_bool_vector</a>&lt; Type, num, typename parallel::template memory_manager&lt; Type, num &gt;, true &gt;</td></tr>
<tr class="memdesc:a648ed7276ad4a6e9e7a049a4e9358037"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classg24__lib_1_1carried__bool__vector.html" title="A container that holds an array of booleans in a given memory context in a space efficient way,...">g24_lib::carried_bool_vector</a></code> that holds the booleans in a way that is appropriate for a specific type of parallelism.  <a href="namespaceg24__lib.html#a648ed7276ad4a6e9e7a049a4e9358037">More...</a><br /></td></tr>
<tr class="separator:a648ed7276ad4a6e9e7a049a4e9358037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f09841e49a05e3e8eaf42b0169c965"><td class="memTemplParams" colspan="2">template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a09f09841e49a05e3e8eaf42b0169c965"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a09f09841e49a05e3e8eaf42b0169c965">cpu_array</a> = <a class="el" href="classg24__lib_1_1simple__array.html">simple_array</a>&lt; Type, num, <a class="el" href="structg24__lib_1_1default__memory__manager.html">default_memory_manager</a>&lt; Type, num &gt;, true &gt;</td></tr>
<tr class="memdesc:a09f09841e49a05e3e8eaf42b0169c965"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classg24__lib_1_1simple__array.html" title="A container that holds an array of objects in a given memory context.">g24_lib::simple_array</a></code> that holds the array in the usual, CPU-addressable memory.  <a href="namespaceg24__lib.html#a09f09841e49a05e3e8eaf42b0169c965">More...</a><br /></td></tr>
<tr class="separator:a09f09841e49a05e3e8eaf42b0169c965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0e1fd8996e0e81f544771ee83bd2fc"><td class="memTemplParams" colspan="2">template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a3e0e1fd8996e0e81f544771ee83bd2fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a3e0e1fd8996e0e81f544771ee83bd2fc">cpu_bool_vector</a> = <a class="el" href="classg24__lib_1_1carried__bool__vector.html">carried_bool_vector</a>&lt; Type, indexer, <a class="el" href="structg24__lib_1_1default__memory__manager.html">default_memory_manager</a>&lt; Type, indexer &gt;, true &gt;</td></tr>
<tr class="memdesc:a3e0e1fd8996e0e81f544771ee83bd2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classg24__lib_1_1carried__bool__vector.html" title="A container that holds an array of booleans in a given memory context in a space efficient way,...">g24_lib::carried_bool_vector</a></code> that holds the booleans in the usual, CPU-addressable memory.  <a href="namespaceg24__lib.html#a3e0e1fd8996e0e81f544771ee83bd2fc">More...</a><br /></td></tr>
<tr class="separator:a3e0e1fd8996e0e81f544771ee83bd2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68e628801b623856bb60a4deaad85c4"><td class="memTemplParams" colspan="2">template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:ae68e628801b623856bb60a4deaad85c4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#ae68e628801b623856bb60a4deaad85c4">cpu_object</a> = <a class="el" href="classg24__lib_1_1managed__object.html">managed_object</a>&lt; Type, num, <a class="el" href="structg24__lib_1_1default__memory__manager.html">default_memory_manager</a>&lt; Type, num &gt;, true &gt;</td></tr>
<tr class="memdesc:ae68e628801b623856bb60a4deaad85c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classg24__lib_1_1managed__object.html" title="A container that holds an object in a given memory context.">g24_lib::managed_object</a></code> that holds the object in the usual, CPU-addressable memory.  <a href="namespaceg24__lib.html#ae68e628801b623856bb60a4deaad85c4">More...</a><br /></td></tr>
<tr class="separator:ae68e628801b623856bb60a4deaad85c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6d7f7fb95ec19aa2ad09dc0561c4a5"><td class="memTemplParams" colspan="2">template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:afe6d7f7fb95ec19aa2ad09dc0561c4a5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#afe6d7f7fb95ec19aa2ad09dc0561c4a5">cpu_split_array</a> = <a class="el" href="structg24__lib_1_1split__member__array.html">split_member_array</a>&lt; Type, num, <a class="el" href="structg24__lib_1_1default__memory__manager.html">default_memory_manager</a>, true &gt;</td></tr>
<tr class="memdesc:afe6d7f7fb95ec19aa2ad09dc0561c4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="structg24__lib_1_1split__member__array.html" title="A container that stores the different members of a struct that can undergo compile time reflection th...">g24_lib::split_member_array</a></code> that holds the array in the usual, CPU-addressable memory.  <a href="namespaceg24__lib.html#afe6d7f7fb95ec19aa2ad09dc0561c4a5">More...</a><br /></td></tr>
<tr class="separator:afe6d7f7fb95ec19aa2ad09dc0561c4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab811624341877094f0d0786c95f59178"><td class="memTemplParams" colspan="2">template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:ab811624341877094f0d0786c95f59178"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#ab811624341877094f0d0786c95f59178">cuda_array</a> = <a class="el" href="classg24__lib_1_1simple__array.html">simple_array</a>&lt; Type, num, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>&lt; Type, num &gt;, true &gt;</td></tr>
<tr class="memdesc:ab811624341877094f0d0786c95f59178"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classg24__lib_1_1simple__array.html" title="A container that holds an array of objects in a given memory context.">g24_lib::simple_array</a></code> that holds the array in the memory of a <code>CUDA-enabled</code> GPU.  <a href="namespaceg24__lib.html#ab811624341877094f0d0786c95f59178">More...</a><br /></td></tr>
<tr class="separator:ab811624341877094f0d0786c95f59178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41af5529f2c640054299e5eae419bb5"><td class="memTemplParams" colspan="2">template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:ae41af5529f2c640054299e5eae419bb5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#ae41af5529f2c640054299e5eae419bb5">cuda_bool_vector</a> = <a class="el" href="classg24__lib_1_1carried__bool__vector.html">carried_bool_vector</a>&lt; Type, indexer, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>&lt; Type, indexer &gt;, true &gt;</td></tr>
<tr class="memdesc:ae41af5529f2c640054299e5eae419bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classg24__lib_1_1carried__bool__vector.html" title="A container that holds an array of booleans in a given memory context in a space efficient way,...">g24_lib::carried_bool_vector</a></code> that holds the booleans in the memory of a <code>CUDA-enabled</code> GPU.  <a href="namespaceg24__lib.html#ae41af5529f2c640054299e5eae419bb5">More...</a><br /></td></tr>
<tr class="separator:ae41af5529f2c640054299e5eae419bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c20ed28f8476d1475c28167bba8c76"><td class="memTemplParams" colspan="2">template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:ad2c20ed28f8476d1475c28167bba8c76"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#ad2c20ed28f8476d1475c28167bba8c76">cuda_kernel_array</a> = <a class="el" href="classg24__lib_1_1simple__array.html">simple_array</a>&lt; Type, num, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>&lt; Type, num &gt;, false &gt;</td></tr>
<tr class="memdesc:ad2c20ed28f8476d1475c28167bba8c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">The appropriate way to pass a <code><a class="el" href="classg24__lib_1_1simple__array.html" title="A container that holds an array of objects in a given memory context.">g24_lib::simple_array</a></code> into a <code>CUDA</code> kernel. Will copy the pointer if the memory already resides in the GPU, so the original array will be addressed and will experience any changes dictated by the kernel.  <a href="namespaceg24__lib.html#ad2c20ed28f8476d1475c28167bba8c76">More...</a><br /></td></tr>
<tr class="separator:ad2c20ed28f8476d1475c28167bba8c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725368462b34139620db9424f256eb7b"><td class="memTemplParams" colspan="2">template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a725368462b34139620db9424f256eb7b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a725368462b34139620db9424f256eb7b">cuda_kernel_bool_vector</a> = <a class="el" href="classg24__lib_1_1carried__bool__vector.html">carried_bool_vector</a>&lt; Type, indexer, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>&lt; Type, indexer &gt;, false &gt;</td></tr>
<tr class="memdesc:a725368462b34139620db9424f256eb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The appropriate way to pass a <code><a class="el" href="classg24__lib_1_1carried__bool__vector.html" title="A container that holds an array of booleans in a given memory context in a space efficient way,...">g24_lib::carried_bool_vector</a></code> into a <code>CUDA</code> kernel. Will copy a pointer if the memory already resides in the GPU, so the original array will be addressed and will experience any changes dictated by the kernel.  <a href="namespaceg24__lib.html#a725368462b34139620db9424f256eb7b">More...</a><br /></td></tr>
<tr class="separator:a725368462b34139620db9424f256eb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9b9b9e48f08f6be83be3cb8bddc120"><td class="memTemplParams" colspan="2">template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a3d9b9b9e48f08f6be83be3cb8bddc120"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a3d9b9b9e48f08f6be83be3cb8bddc120">cuda_kernel_object</a> = <a class="el" href="classg24__lib_1_1managed__object.html">managed_object</a>&lt; Type, num, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>&lt; Type, num &gt;, false &gt;</td></tr>
<tr class="memdesc:a3d9b9b9e48f08f6be83be3cb8bddc120"><td class="mdescLeft">&#160;</td><td class="mdescRight">The appropriate way to pass a <code><a class="el" href="classg24__lib_1_1managed__object.html" title="A container that holds an object in a given memory context.">g24_lib::managed_object</a></code> into a <code>CUDA</code> kernel. Will copy the pointer if the memory already resides in the GPU, so the original array will be addressed and will experience any changes dictated by the kernel.  <a href="namespaceg24__lib.html#a3d9b9b9e48f08f6be83be3cb8bddc120">More...</a><br /></td></tr>
<tr class="separator:a3d9b9b9e48f08f6be83be3cb8bddc120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9b2aadb104111ef615c0c23445b72f"><td class="memTemplParams" colspan="2">template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a6f9b2aadb104111ef615c0c23445b72f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a6f9b2aadb104111ef615c0c23445b72f">cuda_kernel_split_array</a> = <a class="el" href="structg24__lib_1_1split__member__array.html">split_member_array</a>&lt; Type, num, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>, false &gt;</td></tr>
<tr class="memdesc:a6f9b2aadb104111ef615c0c23445b72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The appropriate way to pass a <code><a class="el" href="structg24__lib_1_1split__member__array.html" title="A container that stores the different members of a struct that can undergo compile time reflection th...">g24_lib::split_member_array</a></code> into a <code>CUDA</code> kernel. Will copy the pointer if the memory already resides in the GPU, so the original array will be addressed and will experience any changes dictated by the kernel.  <a href="namespaceg24__lib.html#a6f9b2aadb104111ef615c0c23445b72f">More...</a><br /></td></tr>
<tr class="separator:a6f9b2aadb104111ef615c0c23445b72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e042461ff360a1d44780ed18f84e20"><td class="memTemplParams" colspan="2">template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:af9e042461ff360a1d44780ed18f84e20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#af9e042461ff360a1d44780ed18f84e20">cuda_object</a> = <a class="el" href="classg24__lib_1_1managed__object.html">managed_object</a>&lt; Type, num, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>&lt; Type, num &gt;, true &gt;</td></tr>
<tr class="memdesc:af9e042461ff360a1d44780ed18f84e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classg24__lib_1_1managed__object.html" title="A container that holds an object in a given memory context.">g24_lib::managed_object</a></code> that holds the object in the memory of a <code>CUDA-enabled</code> GPU.  <a href="namespaceg24__lib.html#af9e042461ff360a1d44780ed18f84e20">More...</a><br /></td></tr>
<tr class="separator:af9e042461ff360a1d44780ed18f84e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a44df94474592b8b103a57e1ad195b"><td class="memTemplParams" colspan="2">template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a69a44df94474592b8b103a57e1ad195b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a69a44df94474592b8b103a57e1ad195b">cuda_split_array</a> = <a class="el" href="structg24__lib_1_1split__member__array.html">split_member_array</a>&lt; Type, num, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>, true &gt;</td></tr>
<tr class="memdesc:a69a44df94474592b8b103a57e1ad195b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="structg24__lib_1_1split__member__array.html" title="A container that stores the different members of a struct that can undergo compile time reflection th...">g24_lib::split_member_array</a></code> that holds the array in the memory of a <code>CUDA-enabled</code> GPU.  <a href="namespaceg24__lib.html#a69a44df94474592b8b103a57e1ad195b">More...</a><br /></td></tr>
<tr class="separator:a69a44df94474592b8b103a57e1ad195b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a0cf1c5325fb5405f215e22c8bdde4"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a50a0cf1c5325fb5405f215e22c8bdde4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a50a0cf1c5325fb5405f215e22c8bdde4">indexer_type</a> = typename internals::container_checks&lt; std::decay_t&lt; C &gt; &gt;::indexer</td></tr>
<tr class="memdesc:a50a0cf1c5325fb5405f215e22c8bdde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the indexer type of a container-like class, or void if the class isn't a container.  <a href="namespaceg24__lib.html#a50a0cf1c5325fb5405f215e22c8bdde4">More...</a><br /></td></tr>
<tr class="separator:a50a0cf1c5325fb5405f215e22c8bdde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0f2bbfac983937a3f7370fe4a27b0b"><td class="memTemplParams" colspan="2">template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a0a0f2bbfac983937a3f7370fe4a27b0b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a0a0f2bbfac983937a3f7370fe4a27b0b">managed</a> = <a class="el" href="classg24__lib_1_1managed__object.html">managed_object</a>&lt; Type, num, <a class="el" href="namespaceg24__lib_1_1_memory_context.html#ad7443412ad1c5a53abdc4b78e94231c3">MemoryContext::current_manager</a>&lt; Type, num &gt;, true &gt;</td></tr>
<tr class="memdesc:a0a0f2bbfac983937a3f7370fe4a27b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classg24__lib_1_1managed__object.html" title="A container that holds an object in a given memory context.">g24_lib::managed_object</a></code> that holds the object in the memory appropriate for the current context.  <a href="namespaceg24__lib.html#a0a0f2bbfac983937a3f7370fe4a27b0b">More...</a><br /></td></tr>
<tr class="separator:a0a0f2bbfac983937a3f7370fe4a27b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d36a0633ce92a58b17b2480cde0cb6"><td class="memTemplParams" colspan="2">template&lt;class parallel , class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a97d36a0633ce92a58b17b2480cde0cb6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a97d36a0633ce92a58b17b2480cde0cb6">managed_parallel</a> = <a class="el" href="classg24__lib_1_1managed__object.html">managed_object</a>&lt; Type, num, typename parallel::template memory_manager&lt; Type, num &gt;, true &gt;</td></tr>
<tr class="memdesc:a97d36a0633ce92a58b17b2480cde0cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classg24__lib_1_1managed__object.html" title="A container that holds an object in a given memory context.">g24_lib::managed_object</a></code> that holds the object in a way that is appropriate for a specific type of parallelism.  <a href="namespaceg24__lib.html#a97d36a0633ce92a58b17b2480cde0cb6">More...</a><br /></td></tr>
<tr class="separator:a97d36a0633ce92a58b17b2480cde0cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5a04771b0e792815e9d35b54e32746"><td class="memTemplParams" colspan="2">template&lt;g24_lib::Definitions::default_unsigned_indexer size&gt; </td></tr>
<tr class="memitem:abe5a04771b0e792815e9d35b54e32746"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#abe5a04771b0e792815e9d35b54e32746">signed_integer</a> = typename <a class="el" href="structg24__lib_1_1internals_1_1any__sized__int.html">internals::any_sized_int</a>&lt; size, true &gt;::type</td></tr>
<tr class="memdesc:abe5a04771b0e792815e9d35b54e32746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a signed integer type with a specific number of bytes.  <a href="namespaceg24__lib.html#abe5a04771b0e792815e9d35b54e32746">More...</a><br /></td></tr>
<tr class="separator:abe5a04771b0e792815e9d35b54e32746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b02ea968f04de5bab62a20125ce7a0"><td class="memTemplParams" colspan="2">template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:ae0b02ea968f04de5bab62a20125ce7a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#ae0b02ea968f04de5bab62a20125ce7a0">split_array</a> = <a class="el" href="structg24__lib_1_1split__member__array.html">split_member_array</a>&lt; Type, num, <a class="el" href="namespaceg24__lib_1_1_memory_context.html#ad7443412ad1c5a53abdc4b78e94231c3">MemoryContext::current_manager</a>, true &gt;</td></tr>
<tr class="memdesc:ae0b02ea968f04de5bab62a20125ce7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="structg24__lib_1_1split__member__array.html" title="A container that stores the different members of a struct that can undergo compile time reflection th...">g24_lib::split_member_array</a></code> that holds the array in the memory appropriate for the current context.  <a href="namespaceg24__lib.html#ae0b02ea968f04de5bab62a20125ce7a0">More...</a><br /></td></tr>
<tr class="separator:ae0b02ea968f04de5bab62a20125ce7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fecbb6037aa8e21bbbf5bfe05e556b"><td class="memTemplParams" colspan="2">template&lt;class parallel , class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:ad9fecbb6037aa8e21bbbf5bfe05e556b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#ad9fecbb6037aa8e21bbbf5bfe05e556b">split_array_parallel</a> = <a class="el" href="structg24__lib_1_1split__member__array.html">split_member_array</a>&lt; Type, num, parallel::template memory_manager, true &gt;</td></tr>
<tr class="memdesc:ad9fecbb6037aa8e21bbbf5bfe05e556b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="structg24__lib_1_1split__member__array.html" title="A container that stores the different members of a struct that can undergo compile time reflection th...">g24_lib::split_member_array</a></code> that holds the array in a way that is appropriate for a specific type of parallelism.  <a href="namespaceg24__lib.html#ad9fecbb6037aa8e21bbbf5bfe05e556b">More...</a><br /></td></tr>
<tr class="separator:ad9fecbb6037aa8e21bbbf5bfe05e556b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f23ede94e5a8beeac8997274c58c293"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0f23ede94e5a8beeac8997274c58c293"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a0f23ede94e5a8beeac8997274c58c293">to_CUDA_t</a> = decltype(<a class="el" href="namespaceg24__lib.html#a55cd110ba53c6a6a51bced0cf1fac427">to_CUDA</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="memdesc:a0f23ede94e5a8beeac8997274c58c293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the type of the CUDA-compatible version of <code>T</code>.  <a href="namespaceg24__lib.html#a0f23ede94e5a8beeac8997274c58c293">More...</a><br /></td></tr>
<tr class="separator:a0f23ede94e5a8beeac8997274c58c293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac272351f0f0b8eeb33bc02c484450f96"><td class="memTemplParams" colspan="2">template&lt;g24_lib::Definitions::default_unsigned_indexer size&gt; </td></tr>
<tr class="memitem:ac272351f0f0b8eeb33bc02c484450f96"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#ac272351f0f0b8eeb33bc02c484450f96">unsigned_integer</a> = typename <a class="el" href="structg24__lib_1_1internals_1_1any__sized__int.html">internals::any_sized_int</a>&lt; size, false &gt;::type</td></tr>
<tr class="memdesc:ac272351f0f0b8eeb33bc02c484450f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an unsigned integer type with a specific number of bytes.  <a href="namespaceg24__lib.html#ac272351f0f0b8eeb33bc02c484450f96">More...</a><br /></td></tr>
<tr class="separator:ac272351f0f0b8eeb33bc02c484450f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b455b207b88a2b2fad31a2bd9f0ab4"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a90b455b207b88a2b2fad31a2bd9f0ab4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a90b455b207b88a2b2fad31a2bd9f0ab4">value_type</a> = typename internals::container_checks&lt; std::decay_t&lt; C &gt; &gt;::value</td></tr>
<tr class="memdesc:a90b455b207b88a2b2fad31a2bd9f0ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the value type of a container-like class, or void if the class isn't a container.  <a href="namespaceg24__lib.html#a90b455b207b88a2b2fad31a2bd9f0ab4">More...</a><br /></td></tr>
<tr class="separator:a90b455b207b88a2b2fad31a2bd9f0ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1c69dc6164b980f081d0ae62fc91b5f0"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a1c69dc6164b980f081d0ae62fc91b5f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a1c69dc6164b980f081d0ae62fc91b5f0">ask_comp</a> (const bool reduc)</td></tr>
<tr class="memdesc:a1c69dc6164b980f081d0ae62fc91b5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks the user for a <a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a> number and returns it. If <code>reduc</code> is true, if the complex appears to be in the polar form, the argument is read as a fraction of pi.  <a href="namespaceg24__lib.html#a1c69dc6164b980f081d0ae62fc91b5f0">More...</a><br /></td></tr>
<tr class="separator:a1c69dc6164b980f081d0ae62fc91b5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cda0ddc581b69bbc6d6e8b4b5278aeb"><td class="memTemplParams" colspan="2">template&lt;class T , class stream &gt; </td></tr>
<tr class="memitem:a7cda0ddc581b69bbc6d6e8b4b5278aeb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a7cda0ddc581b69bbc6d6e8b4b5278aeb">binary_input</a> (stream &amp;s, T &amp;in)</td></tr>
<tr class="memdesc:a7cda0ddc581b69bbc6d6e8b4b5278aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inputs an object in binary mode.  <a href="namespaceg24__lib.html#a7cda0ddc581b69bbc6d6e8b4b5278aeb">More...</a><br /></td></tr>
<tr class="separator:a7cda0ddc581b69bbc6d6e8b4b5278aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cefdfa1b2f7d066e4ba87aa99cdedd"><td class="memTemplParams" colspan="2">template&lt;class T , class stream &gt; </td></tr>
<tr class="memitem:a14cefdfa1b2f7d066e4ba87aa99cdedd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a14cefdfa1b2f7d066e4ba87aa99cdedd">binary_output</a> (stream &amp;s, const T &amp;out)</td></tr>
<tr class="memdesc:a14cefdfa1b2f7d066e4ba87aa99cdedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs an object in binary mode.  <a href="namespaceg24__lib.html#a14cefdfa1b2f7d066e4ba87aa99cdedd">More...</a><br /></td></tr>
<tr class="separator:a14cefdfa1b2f7d066e4ba87aa99cdedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5517c8b80dd7e62bc9d9154ca766bcbe"><td class="memTemplParams" colspan="2">template&lt;class factorT , factorT num, factorT denom, class ... frac_gens&gt; </td></tr>
<tr class="memitem:a5517c8b80dd7e62bc9d9154ca766bcbe"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a5517c8b80dd7e62bc9d9154ca766bcbe">butcher_entry</a> (const <a class="el" href="structg24__lib_1_1constexpr__fraction.html">constexpr_fraction</a>&lt; factorT, num, denom &gt; eval_t, const frac_gens ... fracs)</td></tr>
<tr class="separator:a5517c8b80dd7e62bc9d9154ca766bcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e8e922b0d8b6e3214cec2d356075a1"><td class="memTemplParams" colspan="2">template&lt;class factorT , factorT num, factorT denom, class ... frac_gens&gt; </td></tr>
<tr class="memitem:a60e8e922b0d8b6e3214cec2d356075a1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a60e8e922b0d8b6e3214cec2d356075a1">butcher_final</a> (const <a class="el" href="structg24__lib_1_1constexpr__fraction.html">constexpr_fraction</a>&lt; factorT, num, denom &gt; frac1, const frac_gens ... fracs)</td></tr>
<tr class="separator:a60e8e922b0d8b6e3214cec2d356075a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3591d08d7d5be4ba64e61df42483223e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3591d08d7d5be4ba64e61df42483223e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a3591d08d7d5be4ba64e61df42483223e">compile_time_type_name</a> ()</td></tr>
<tr class="memdesc:a3591d08d7d5be4ba64e61df42483223e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a compile-time type name based on a non-portable trick involving compiler specific macros.  <a href="namespaceg24__lib.html#a3591d08d7d5be4ba64e61df42483223e">More...</a><br /></td></tr>
<tr class="separator:a3591d08d7d5be4ba64e61df42483223e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bec1de2c8b081866513d9a9dffb44e6"><td class="memTemplParams" colspan="2">template&lt;class Tarr_vec , class ndview_like , class cellsizeT , class indexer  = g24_lib::Definitions::default_signed_indexer, class factorT  = g24_lib::Definitions::default_floating_point&gt; </td></tr>
<tr class="memitem:a8bec1de2c8b081866513d9a9dffb44e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a8bec1de2c8b081866513d9a9dffb44e6">curl</a> (const Tarr_vec &amp;arr, const indexer elem, const ndview_like &amp;nd, const cellsizeT &amp;cs, const indexer accuracy=1)</td></tr>
<tr class="memdesc:a8bec1de2c8b081866513d9a9dffb44e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the curl of <code>arr</code> at point <code>elem</code>.  <a href="namespaceg24__lib.html#a8bec1de2c8b081866513d9a9dffb44e6">More...</a><br /></td></tr>
<tr class="separator:a8bec1de2c8b081866513d9a9dffb44e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac430c3b4107b5305fe8c44d8a25eb1"><td class="memTemplParams" colspan="2">template&lt;class C , bool by_value = false&gt; </td></tr>
<tr class="memitem:acac430c3b4107b5305fe8c44d8a25eb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#acac430c3b4107b5305fe8c44d8a25eb1">defer</a> (C &amp;&amp;x)</td></tr>
<tr class="memdesc:acac430c3b4107b5305fe8c44d8a25eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defers the evaluation of most overloadable operators on <code>x</code>.  <a href="namespaceg24__lib.html#acac430c3b4107b5305fe8c44d8a25eb1">More...</a><br /></td></tr>
<tr class="separator:acac430c3b4107b5305fe8c44d8a25eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6ba1f821989a3d8d4523af275bd9c1"><td class="memTemplParams" colspan="2">template&lt;class C , bool by_value = false&gt; </td></tr>
<tr class="memitem:ade6ba1f821989a3d8d4523af275bd9c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#ade6ba1f821989a3d8d4523af275bd9c1">defer</a> (const C &amp;x)</td></tr>
<tr class="memdesc:ade6ba1f821989a3d8d4523af275bd9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defers the evaluation of most overloadable operators on <code>x</code>.  <a href="namespaceg24__lib.html#ade6ba1f821989a3d8d4523af275bd9c1">More...</a><br /></td></tr>
<tr class="separator:ade6ba1f821989a3d8d4523af275bd9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bc5f4f4c2af077d418ecee738b76b4"><td class="memTemplParams" colspan="2">template&lt;class Tarr , class ndview_like , class cellsizeT , class indexer  = g24_lib::Definitions::default_signed_indexer, class factorT  = g24_lib::Definitions::default_floating_point&gt; </td></tr>
<tr class="memitem:a82bc5f4f4c2af077d418ecee738b76b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a82bc5f4f4c2af077d418ecee738b76b4">derivative</a> (const indexer dimension, const Tarr &amp;arr, const indexer elem, const ndview_like &amp;nd, const cellsizeT &amp;cs, const indexer order=1, const indexer accuracy=2)</td></tr>
<tr class="memdesc:a82bc5f4f4c2af077d418ecee738b76b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a derivative along dimension <code>dimension</code> of an array with multidimensional properties given by <code>nd</code>.  <a href="namespaceg24__lib.html#a82bc5f4f4c2af077d418ecee738b76b4">More...</a><br /></td></tr>
<tr class="separator:a82bc5f4f4c2af077d418ecee738b76b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba16e986d4cc5514774c378585c5a8ec"><td class="memTemplParams" colspan="2">template&lt;class Tarr_vec , class ndview_like , class cellsizeT , class indexer  = g24_lib::Definitions::default_signed_indexer, class factorT  = g24_lib::Definitions::default_floating_point&gt; </td></tr>
<tr class="memitem:aba16e986d4cc5514774c378585c5a8ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#aba16e986d4cc5514774c378585c5a8ec">divergence</a> (const Tarr_vec &amp;arr, const indexer elem, const ndview_like &amp;nd, const cellsizeT &amp;cs, const indexer accuracy=1)</td></tr>
<tr class="memdesc:aba16e986d4cc5514774c378585c5a8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the divergence of <code>arr</code> at point <code>elem</code>.  <a href="namespaceg24__lib.html#aba16e986d4cc5514774c378585c5a8ec">More...</a><br /></td></tr>
<tr class="separator:aba16e986d4cc5514774c378585c5a8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcc4defcab902e1b79de20d88f95c9f"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:aadcc4defcab902e1b79de20d88f95c9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#aadcc4defcab902e1b79de20d88f95c9f">fast_read_comp</a> (std::istream &amp;s, <a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt; Type &gt; &amp;c, const bool pol, const bool reduc)</td></tr>
<tr class="memdesc:aadcc4defcab902e1b79de20d88f95c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a <a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a> from a stream. If <code>pol</code> is false, in cartesian form; if <code>pol</code> is true, in polar form, with the argument being as a fraction of pi if <code>reduc</code> is true or as a number in <code>]-pi, pi]</code> if <code>recuc</code> is false.  <a href="namespaceg24__lib.html#aadcc4defcab902e1b79de20d88f95c9f">More...</a><br /></td></tr>
<tr class="separator:aadcc4defcab902e1b79de20d88f95c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3355d33db784a10a65946963a9a7da92"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a3355d33db784a10a65946963a9a7da92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a3355d33db784a10a65946963a9a7da92">fast_read_comp</a> (std::istream &amp;s, const bool pol, const bool reduc)</td></tr>
<tr class="memdesc:a3355d33db784a10a65946963a9a7da92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a> read from a stream. If <code>pol</code> is false, in cartesian form; if <code>pol</code> is true, in polar form, with the argument being as a fraction of pi if <code>reduc</code> is true or as a number in <code>]-pi, pi]</code> if <code>recuc</code> is false.  <a href="namespaceg24__lib.html#a3355d33db784a10a65946963a9a7da92">More...</a><br /></td></tr>
<tr class="separator:a3355d33db784a10a65946963a9a7da92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47229c308fb422b5131c5cf9c9f40793"><td class="memTemplParams" colspan="2">template&lt;class base_T , class exp_T  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a47229c308fb422b5131c5cf9c9f40793"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> base_T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a47229c308fb422b5131c5cf9c9f40793">fastpow</a> (const base_T &amp;base, exp_T exp)</td></tr>
<tr class="memdesc:a47229c308fb422b5131c5cf9c9f40793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expectably efficient implementation of exponentiation by integers.  <a href="namespaceg24__lib.html#a47229c308fb422b5131c5cf9c9f40793">More...</a><br /></td></tr>
<tr class="separator:a47229c308fb422b5131c5cf9c9f40793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae992351f2d68dc94a5fca4059dfe0762"><td class="memTemplParams" colspan="2">template&lt;class Tarr , class ndview_like , class cellsizeT , class indexer  = g24_lib::Definitions::default_signed_indexer, class factorT  = g24_lib::Definitions::default_floating_point&gt; </td></tr>
<tr class="memitem:ae992351f2d68dc94a5fca4059dfe0762"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#ae992351f2d68dc94a5fca4059dfe0762">gradient</a> (const Tarr &amp;arr, const indexer elem, const ndview_like &amp;nd, const cellsizeT &amp;cs, const indexer accuracy=1)</td></tr>
<tr class="memdesc:ae992351f2d68dc94a5fca4059dfe0762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the gradient of <code>arr</code> at point <code>elem</code>.  <a href="namespaceg24__lib.html#ae992351f2d68dc94a5fca4059dfe0762">More...</a><br /></td></tr>
<tr class="separator:ae992351f2d68dc94a5fca4059dfe0762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d6932d0994766d8f67328b72b40e86"><td class="memTemplParams" colspan="2">template&lt;class number , class ArrT , class indexer , indexer dim, indexer skipped = 0&gt; </td></tr>
<tr class="memitem:a35d6932d0994766d8f67328b72b40e86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a35d6932d0994766d8f67328b72b40e86">interpolate_from_grid</a> (const ArrT &amp;arr, const <a class="el" href="classg24__lib_1_1fspoint.html">fspoint</a>&lt; indexer, indexer, dim &gt; cell, const <a class="el" href="classg24__lib_1_1fspoint.html">fspoint</a>&lt; number, indexer, dim &gt; positions, const <a class="el" href="classg24__lib_1_1ndview.html">ndview</a>&lt; indexer, dim &gt; view)</td></tr>
<tr class="memdesc:a35d6932d0994766d8f67328b72b40e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation in a multidimensional array.  <a href="namespaceg24__lib.html#a35d6932d0994766d8f67328b72b40e86">More...</a><br /></td></tr>
<tr class="separator:a35d6932d0994766d8f67328b72b40e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8539f8a9fcd784224145c916fd81cd"><td class="memTemplParams" colspan="2">template&lt;class number , class ArrT , class indexer , indexer dim, indexer skipped = 0&gt; </td></tr>
<tr class="memitem:a0c8539f8a9fcd784224145c916fd81cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a0c8539f8a9fcd784224145c916fd81cd">interpolate_from_grid</a> (const ArrT &amp;arr, const <a class="el" href="classg24__lib_1_1fspoint.html">fspoint</a>&lt; indexer, indexer, dim &gt; cell, const <a class="el" href="classg24__lib_1_1fspoint.html">fspoint</a>&lt; number, indexer, dim &gt; positions, const <a class="el" href="classg24__lib_1_1ndview.html">ndview</a>&lt; indexer, dim &gt; view, const indexer accuracy)</td></tr>
<tr class="memdesc:a0c8539f8a9fcd784224145c916fd81cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial interpolation in a multidimensional array.  <a href="namespaceg24__lib.html#a0c8539f8a9fcd784224145c916fd81cd">More...</a><br /></td></tr>
<tr class="separator:a0c8539f8a9fcd784224145c916fd81cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab821e066d7d3ed0ac3a63c91a617d6ef"><td class="memTemplParams" colspan="2">template&lt;class number , class ArrT , class indexer &gt; </td></tr>
<tr class="memitem:ab821e066d7d3ed0ac3a63c91a617d6ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#ab821e066d7d3ed0ac3a63c91a617d6ef">interpolate_from_grid_1D</a> (const ArrT &amp;arr, const indexer elem, const number position, const indexer separation=1)</td></tr>
<tr class="memdesc:ab821e066d7d3ed0ac3a63c91a617d6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation from a unidimensional array.  <a href="namespaceg24__lib.html#ab821e066d7d3ed0ac3a63c91a617d6ef">More...</a><br /></td></tr>
<tr class="separator:ab821e066d7d3ed0ac3a63c91a617d6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf8114ea148266dfb19a3b571691f57"><td class="memTemplParams" colspan="2">template&lt;class number , class ArrT , class indexer &gt; </td></tr>
<tr class="memitem:a9cf8114ea148266dfb19a3b571691f57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a9cf8114ea148266dfb19a3b571691f57">interpolate_from_grid_1D</a> (const ArrT &amp;arr, const indexer elem, const number position, const indexer to_left, const indexer to_right, const indexer separation=1)</td></tr>
<tr class="memdesc:a9cf8114ea148266dfb19a3b571691f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial interpolation from a unidimensional array (with a number of points).  <a href="namespaceg24__lib.html#a9cf8114ea148266dfb19a3b571691f57">More...</a><br /></td></tr>
<tr class="separator:a9cf8114ea148266dfb19a3b571691f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d08a9234a50079bd5d57ad577c436e"><td class="memTemplParams" colspan="2">template&lt;class Tarr , class ndview_like , class cellsizeT , class indexer  = g24_lib::Definitions::default_signed_indexer, class factorT  = g24_lib::Definitions::default_floating_point&gt; </td></tr>
<tr class="memitem:a27d08a9234a50079bd5d57ad577c436e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a27d08a9234a50079bd5d57ad577c436e">laplacian</a> (const Tarr &amp;arr, const indexer elem, const ndview_like &amp;nd, const cellsizeT &amp;cs, const indexer accuracy=1)</td></tr>
<tr class="memdesc:a27d08a9234a50079bd5d57ad577c436e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the laplacian of <code>arr</code> at point <code>elem</code>.  <a href="namespaceg24__lib.html#a27d08a9234a50079bd5d57ad577c436e">More...</a><br /></td></tr>
<tr class="separator:a27d08a9234a50079bd5d57ad577c436e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab1b220c0489ecf72300d15a97ee2f3"><td class="memTemplParams" colspan="2">template&lt;class butcher_final_like &gt; </td></tr>
<tr class="memitem:a8ab1b220c0489ecf72300d15a97ee2f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a8ab1b220c0489ecf72300d15a97ee2f3">make_butcher_table</a> (const butcher_final_like)</td></tr>
<tr class="memdesc:a8ab1b220c0489ecf72300d15a97ee2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization for the Euler case.  <a href="namespaceg24__lib.html#a8ab1b220c0489ecf72300d15a97ee2f3">More...</a><br /></td></tr>
<tr class="separator:a8ab1b220c0489ecf72300d15a97ee2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273f68e2c7f9978ff8e08529a4b43f23"><td class="memTemplParams" colspan="2">template&lt;class butcher_final_like , class ... butcher_entry_likes&gt; </td></tr>
<tr class="memitem:a273f68e2c7f9978ff8e08529a4b43f23"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a273f68e2c7f9978ff8e08529a4b43f23">make_butcher_table</a> (const butcher_final_like, const butcher_entry_likes ... entries)</td></tr>
<tr class="memdesc:a273f68e2c7f9978ff8e08529a4b43f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Butcher tableau from the provided Butcher entries.  <a href="namespaceg24__lib.html#a273f68e2c7f9978ff8e08529a4b43f23">More...</a><br /></td></tr>
<tr class="separator:a273f68e2c7f9978ff8e08529a4b43f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f20d929ebd786f26278e241d9cf1e95"><td class="memTemplParams" colspan="2">template&lt;class butcher_final_like1 , class butcher_final_like2 , class ... butcher_entry_likes&gt; </td></tr>
<tr class="memitem:a2f20d929ebd786f26278e241d9cf1e95"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a2f20d929ebd786f26278e241d9cf1e95">make_extended_butcher_table</a> (const butcher_final_like1 b1, const butcher_final_like2 b2, const butcher_entry_likes ... entries)</td></tr>
<tr class="memdesc:a2f20d929ebd786f26278e241d9cf1e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an extended Butcher tableau from the provided Butcher entries.  <a href="namespaceg24__lib.html#a2f20d929ebd786f26278e241d9cf1e95">More...</a><br /></td></tr>
<tr class="separator:a2f20d929ebd786f26278e241d9cf1e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade919fccf337541b1ed0f9384d8c612d"><td class="memTemplParams" colspan="2">template&lt;class intg &gt; </td></tr>
<tr class="memitem:ade919fccf337541b1ed0f9384d8c612d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> intg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#ade919fccf337541b1ed0f9384d8c612d">min_power_2</a> (const intg val)</td></tr>
<tr class="memdesc:ade919fccf337541b1ed0f9384d8c612d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the minimum power of 2 larger than or equal to the input.  <a href="namespaceg24__lib.html#ade919fccf337541b1ed0f9384d8c612d">More...</a><br /></td></tr>
<tr class="separator:ade919fccf337541b1ed0f9384d8c612d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd4763008d09fdd7b9953de2c4c9a91"><td class="memTemplParams" colspan="2">template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer, indexer Size = g24_lib::Definitions::default_fixed_size&gt; </td></tr>
<tr class="memitem:a8fd4763008d09fdd7b9953de2c4c9a91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classg24__lib_1_1fspoint.html">fspoint</a>&lt; Type, indexer, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a8fd4763008d09fdd7b9953de2c4c9a91">raw_read_fspoint</a> (std::istream &amp;s)</td></tr>
<tr class="memdesc:a8fd4763008d09fdd7b9953de2c4c9a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>fspoint</code> read from a stream.  <a href="namespaceg24__lib.html#a8fd4763008d09fdd7b9953de2c4c9a91">More...</a><br /></td></tr>
<tr class="separator:a8fd4763008d09fdd7b9953de2c4c9a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36900ec737d8ed254b5580d9c146267a"><td class="memTemplParams" colspan="2">template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a36900ec737d8ed254b5580d9c146267a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classg24__lib_1_1point.html">point</a>&lt; Type, indexer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a36900ec737d8ed254b5580d9c146267a">raw_read_point</a> (std::istream &amp;s)</td></tr>
<tr class="separator:a36900ec737d8ed254b5580d9c146267a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c0b2b14c8f2234aeaae138fbef9dbc"><td class="memTemplParams" colspan="2">template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer&gt; </td></tr>
<tr class="memitem:a92c0b2b14c8f2234aeaae138fbef9dbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classg24__lib_1_1point.html">point</a>&lt; Type, indexer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a92c0b2b14c8f2234aeaae138fbef9dbc">raw_read_point</a> (std::istream &amp;s, const indexer num)</td></tr>
<tr class="separator:a92c0b2b14c8f2234aeaae138fbef9dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe55b414ae892551fbf319bcba5e388"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a1fe55b414ae892551fbf319bcba5e388"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a1fe55b414ae892551fbf319bcba5e388">read_comp</a> (std::istream &amp;s, <a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt; Type &gt; &amp;c, const bool reduc)</td></tr>
<tr class="memdesc:a1fe55b414ae892551fbf319bcba5e388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a <a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a> from values read from a stream. If <code>reduc</code> is true, if the complex appears to be in the polar form, the argument is read as a fraction of pi.  <a href="namespaceg24__lib.html#a1fe55b414ae892551fbf319bcba5e388">More...</a><br /></td></tr>
<tr class="separator:a1fe55b414ae892551fbf319bcba5e388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0795a86f50105085a1f43555e0355553"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a0795a86f50105085a1f43555e0355553"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a0795a86f50105085a1f43555e0355553">read_comp</a> (std::istream &amp;s, const bool reduc)</td></tr>
<tr class="memdesc:a0795a86f50105085a1f43555e0355553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a> read from a stream. If <code>reduc</code> is true, if the complex appears to be in the polar form, the argument is read as a fraction of pi.  <a href="namespaceg24__lib.html#a0795a86f50105085a1f43555e0355553">More...</a><br /></td></tr>
<tr class="separator:a0795a86f50105085a1f43555e0355553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502ae08493e867416f5b6dace7cdc892"><td class="memTemplParams" colspan="2">template&lt;class Type , class Ret  = Type&gt; </td></tr>
<tr class="memitem:a502ae08493e867416f5b6dace7cdc892"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> Ret&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a502ae08493e867416f5b6dace7cdc892">sign</a> (Type num)</td></tr>
<tr class="memdesc:a502ae08493e867416f5b6dace7cdc892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Branchlessly gives the sign of something with comparison operators.  <a href="namespaceg24__lib.html#a502ae08493e867416f5b6dace7cdc892">More...</a><br /></td></tr>
<tr class="separator:a502ae08493e867416f5b6dace7cdc892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf046e132ed3d55b828a64d6011f359"><td class="memTemplParams" colspan="2">template&lt;class method , class Func_T , class object , class time_type , class tol_type , class ... Args&gt; </td></tr>
<tr class="memitem:aedf046e132ed3d55b828a64d6011f359"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#aedf046e132ed3d55b828a64d6011f359">simple_evolve</a> (Func_T &amp;&amp;f, object &amp;&amp;obj, const time_type &amp;current, const time_type &amp;dt, const tol_type &amp;tol, Args &amp;&amp;... params)</td></tr>
<tr class="memdesc:aedf046e132ed3d55b828a64d6011f359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a simpler wrapper for <code><a class="el" href="classg24__lib_1_1temporal__evolver.html" title="Evolves a function in time according to the Runge-Kutta method specified by butcher_tableau.">g24_lib::temporal_evolver</a></code> for objects that are known to be simple to update (i. e., not arrays, so something like a scalar or a vector function).  <a href="namespaceg24__lib.html#aedf046e132ed3d55b828a64d6011f359">More...</a><br /></td></tr>
<tr class="separator:aedf046e132ed3d55b828a64d6011f359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4060743265c190dc087fb153c318cdf6"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a4060743265c190dc087fb153c318cdf6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a4060743265c190dc087fb153c318cdf6">stand</a> (const Type &amp;x)</td></tr>
<tr class="memdesc:a4060743265c190dc087fb153c318cdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Branchlessly clamps something to <img class="formulaInl" alt="$\left ]-1,1\right]$" src="form_0.png"/>.  <a href="namespaceg24__lib.html#a4060743265c190dc087fb153c318cdf6">More...</a><br /></td></tr>
<tr class="separator:a4060743265c190dc087fb153c318cdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715568c02201d4d5d8f41e3ed8ae647d"><td class="memTemplParams" colspan="2">template&lt;class T , class stream &gt; </td></tr>
<tr class="memitem:a715568c02201d4d5d8f41e3ed8ae647d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a715568c02201d4d5d8f41e3ed8ae647d">textual_input</a> (stream &amp;s, T &amp;in)</td></tr>
<tr class="memdesc:a715568c02201d4d5d8f41e3ed8ae647d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inputs an object in text mode.  <a href="namespaceg24__lib.html#a715568c02201d4d5d8f41e3ed8ae647d">More...</a><br /></td></tr>
<tr class="separator:a715568c02201d4d5d8f41e3ed8ae647d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3886bf5ea73ba62b0da62535a5fd1f"><td class="memTemplParams" colspan="2">template&lt;class T , class stream , class str  = std::basic_string&lt;typename stream::char_type&gt;&gt; </td></tr>
<tr class="memitem:a0d3886bf5ea73ba62b0da62535a5fd1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a0d3886bf5ea73ba62b0da62535a5fd1f">textual_output</a> (stream &amp;s, const T &amp;out, const str &amp;separator=&quot; &quot;)</td></tr>
<tr class="memdesc:a0d3886bf5ea73ba62b0da62535a5fd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs an object in text mode.  <a href="namespaceg24__lib.html#a0d3886bf5ea73ba62b0da62535a5fd1f">More...</a><br /></td></tr>
<tr class="separator:a0d3886bf5ea73ba62b0da62535a5fd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cd110ba53c6a6a51bced0cf1fac427"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a55cd110ba53c6a6a51bced0cf1fac427"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a55cd110ba53c6a6a51bced0cf1fac427">to_CUDA</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:a55cd110ba53c6a6a51bced0cf1fac427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a form of <code>obj</code> that is suitable to be operated on in a <code>CUDA</code> kernel.  <a href="namespaceg24__lib.html#a55cd110ba53c6a6a51bced0cf1fac427">More...</a><br /></td></tr>
<tr class="separator:a55cd110ba53c6a6a51bced0cf1fac427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ffda1c518ace10422843a0636ed26a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a82ffda1c518ace10422843a0636ed26a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a82ffda1c518ace10422843a0636ed26a">to_CUDA</a> (T &amp;obj)</td></tr>
<tr class="memdesc:a82ffda1c518ace10422843a0636ed26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a form of <code>obj</code> that is suitable to be operated on in a <code>CUDA</code> kernel.  <a href="namespaceg24__lib.html#a82ffda1c518ace10422843a0636ed26a">More...</a><br /></td></tr>
<tr class="separator:a82ffda1c518ace10422843a0636ed26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9a4b8433b4294030c0182cf59731e3c0"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a9a4b8433b4294030c0182cf59731e3c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a9a4b8433b4294030c0182cf59731e3c0">is_container</a> = !(std::is_void_v&lt;<a class="el" href="namespaceg24__lib.html#a50a0cf1c5325fb5405f215e22c8bdde4">indexer_type</a>&lt;C&gt;&gt; || std::is_void_v&lt;<a class="el" href="namespaceg24__lib.html#a90b455b207b88a2b2fad31a2bd9f0ab4">value_type</a>&lt;C&gt;&gt;)</td></tr>
<tr class="memdesc:a9a4b8433b4294030c0182cf59731e3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>C</code> is a valid container for the purposes of this library.  <a href="namespaceg24__lib.html#a9a4b8433b4294030c0182cf59731e3c0">More...</a><br /></td></tr>
<tr class="separator:a9a4b8433b4294030c0182cf59731e3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db548d9ef3d2229f62c56b98e010c61"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a8db548d9ef3d2229f62c56b98e010c61"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a8db548d9ef3d2229f62c56b98e010c61">is_deferred</a> = std::is_base_of_v&lt;internals::deferred_base,std::decay_t&lt;C&gt;&gt;</td></tr>
<tr class="memdesc:a8db548d9ef3d2229f62c56b98e010c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>C</code> expresses a type on which the operations are deferred.  <a href="namespaceg24__lib.html#a8db548d9ef3d2229f62c56b98e010c61">More...</a><br /></td></tr>
<tr class="separator:a8db548d9ef3d2229f62c56b98e010c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83d4e45695ca05e650e70bfc607d0fc"><td class="memTemplParams" colspan="2">template&lt;class context &gt; </td></tr>
<tr class="memitem:ac83d4e45695ca05e650e70bfc607d0fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#ac83d4e45695ca05e650e70bfc607d0fc">is_memory_context</a> = std::is_base_of_v&lt;<a class="el" href="structg24__lib_1_1_memory_context_1_1memory__context__base.html">MemoryContext::memory_context_base</a>, context&gt;</td></tr>
<tr class="memdesc:ac83d4e45695ca05e650e70bfc607d0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>context</code> is a valid memory context.  <a href="namespaceg24__lib.html#ac83d4e45695ca05e650e70bfc607d0fc">More...</a><br /></td></tr>
<tr class="separator:ac83d4e45695ca05e650e70bfc607d0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e15eae43038dedad37a817fd3c4fb2"><td class="memTemplParams" colspan="2">template&lt;class manager &gt; </td></tr>
<tr class="memitem:aa8e15eae43038dedad37a817fd3c4fb2"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#aa8e15eae43038dedad37a817fd3c4fb2">is_memory_manager</a> = internals::memory_manager_checker&lt;manager&gt;::is_manager</td></tr>
<tr class="memdesc:aa8e15eae43038dedad37a817fd3c4fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>manager</code> is a valid memory manager.  <a href="namespaceg24__lib.html#aa8e15eae43038dedad37a817fd3c4fb2">More...</a><br /></td></tr>
<tr class="separator:aa8e15eae43038dedad37a817fd3c4fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cb719a58a528fd6413386435a5eb6b"><td class="memTemplParams" colspan="2">template&lt;class parallel &gt; </td></tr>
<tr class="memitem:a26cb719a58a528fd6413386435a5eb6b"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#a26cb719a58a528fd6413386435a5eb6b">is_parallelism</a> = std::is_base_of_v&lt;<a class="el" href="structg24__lib_1_1_parallelism_1_1parallelism__base.html">Parallelism::parallelism_base</a>, parallel&gt;</td></tr>
<tr class="memdesc:a26cb719a58a528fd6413386435a5eb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>parallel</code> is a valid form of parallelism.  <a href="namespaceg24__lib.html#a26cb719a58a528fd6413386435a5eb6b">More...</a><br /></td></tr>
<tr class="separator:a26cb719a58a528fd6413386435a5eb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4c4414ad6148853a74bab54d4133e7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afe4c4414ad6148853a74bab54d4133e7"><td class="memTemplItemLeft" align="right" valign="top">static constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceg24__lib.html#afe4c4414ad6148853a74bab54d4133e7">pi</a></td></tr>
<tr class="memdesc:afe4c4414ad6148853a74bab54d4133e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object of type <code>T</code> holding the value of pi. Precision assured up to 512 decimal places, assuming the type supports it, otherwise rounded to the appropriate precision...  <a href="namespaceg24__lib.html#afe4c4414ad6148853a74bab54d4133e7">More...</a><br /></td></tr>
<tr class="separator:afe4c4414ad6148853a74bab54d4133e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace where all the library resides. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="af2a860556619930385d178a47672fd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a860556619930385d178a47672fd6b">&#9670;&nbsp;</a></span>array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#af2a860556619930385d178a47672fd6b">g24_lib::array</a> = typedef <a class="el" href="classg24__lib_1_1simple__array.html">simple_array</a> &lt;Type, num, <a class="el" href="namespaceg24__lib_1_1_memory_context.html#ad7443412ad1c5a53abdc4b78e94231c3">MemoryContext::current_manager</a>&lt;Type, num&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="classg24__lib_1_1simple__array.html" title="A container that holds an array of objects in a given memory context.">g24_lib::simple_array</a></code> that holds the array in the memory appropriate for the current context. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in the array.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simple__array_8h_source.html#l00841">841</a> of file <a class="el" href="simple__array_8h_source.html">simple_array.h</a>.</p>

</div>
</div>
<a id="a01c56203165aa91296a62a7df111105a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c56203165aa91296a62a7df111105a">&#9670;&nbsp;</a></span>array_parallel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class parallel , class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a01c56203165aa91296a62a7df111105a">g24_lib::array_parallel</a> = typedef <a class="el" href="classg24__lib_1_1simple__array.html">simple_array</a> &lt;Type, num, typename parallel::template memory_manager&lt;Type, num&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="classg24__lib_1_1simple__array.html" title="A container that holds an array of objects in a given memory context.">g24_lib::simple_array</a></code> that holds the array in a way that is appropriate for a specific type of parallelism. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in the array.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
    <tr><td class="paramname">parallel</td><td>A type of parallelism.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>.</dd>
<dd>
<code>parallel</code> must be a valid type of parallelism, that is, it must satisfy <code><a class="el" href="namespaceg24__lib.html#a26cb719a58a528fd6413386435a5eb6b" title="Checks if parallel is a valid form of parallelism.">g24_lib::is_parallelism</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simple__array_8h_source.html#l00903">903</a> of file <a class="el" href="simple__array_8h_source.html">simple_array.h</a>.</p>

</div>
</div>
<a id="a397806504e77306f3ad9a7229e3a0f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397806504e77306f3ad9a7229e3a0f5c">&#9670;&nbsp;</a></span>bool_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a397806504e77306f3ad9a7229e3a0f5c">g24_lib::bool_vector</a> = typedef <a class="el" href="classg24__lib_1_1carried__bool__vector.html">carried_bool_vector</a> &lt;Type, indexer, <a class="el" href="namespaceg24__lib_1_1_memory_context.html#ad7443412ad1c5a53abdc4b78e94231c3">MemoryContext::current_manager</a>&lt;Type, indexer&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="classg24__lib_1_1carried__bool__vector.html" title="A container that holds an array of booleans in a given memory context in a space efficient way,...">g24_lib::carried_bool_vector</a></code> that holds the booleans in the memory appropriate for the current context. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in whose bitwise representation the booleans will be packed (the <em>blocks</em>).</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="carried__bool__vector_8h_source.html#l00781">781</a> of file <a class="el" href="carried__bool__vector_8h_source.html">carried_bool_vector.h</a>.</p>

</div>
</div>
<a id="a648ed7276ad4a6e9e7a049a4e9358037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648ed7276ad4a6e9e7a049a4e9358037">&#9670;&nbsp;</a></span>bool_vector_parallel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class parallel , class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a648ed7276ad4a6e9e7a049a4e9358037">g24_lib::bool_vector_parallel</a> = typedef <a class="el" href="classg24__lib_1_1carried__bool__vector.html">carried_bool_vector</a>&lt;Type, num, typename parallel::template memory_manager&lt;Type, num&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="classg24__lib_1_1carried__bool__vector.html" title="A container that holds an array of booleans in a given memory context in a space efficient way,...">g24_lib::carried_bool_vector</a></code> that holds the booleans in a way that is appropriate for a specific type of parallelism. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in whose bitwise representation the booleans will be packed (the <em>blocks</em>).</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>.</dd>
<dd>
<code>parallel</code> must be a valid type of parallelism, that is, it must satisfy <code><a class="el" href="namespaceg24__lib.html#a26cb719a58a528fd6413386435a5eb6b" title="Checks if parallel is a valid form of parallelism.">g24_lib::is_parallelism</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="carried__bool__vector_8h_source.html#l00838">838</a> of file <a class="el" href="carried__bool__vector_8h_source.html">carried_bool_vector.h</a>.</p>

</div>
</div>
<a id="a09f09841e49a05e3e8eaf42b0169c965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f09841e49a05e3e8eaf42b0169c965">&#9670;&nbsp;</a></span>cpu_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a09f09841e49a05e3e8eaf42b0169c965">g24_lib::cpu_array</a> = typedef <a class="el" href="classg24__lib_1_1simple__array.html">simple_array</a> &lt;Type, num, <a class="el" href="structg24__lib_1_1default__memory__manager.html">default_memory_manager</a>&lt;Type, num&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="classg24__lib_1_1simple__array.html" title="A container that holds an array of objects in a given memory context.">g24_lib::simple_array</a></code> that holds the array in the usual, CPU-addressable memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in the array.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simple__array_8h_source.html#l00854">854</a> of file <a class="el" href="simple__array_8h_source.html">simple_array.h</a>.</p>

</div>
</div>
<a id="a3e0e1fd8996e0e81f544771ee83bd2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0e1fd8996e0e81f544771ee83bd2fc">&#9670;&nbsp;</a></span>cpu_bool_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a3e0e1fd8996e0e81f544771ee83bd2fc">g24_lib::cpu_bool_vector</a> = typedef <a class="el" href="classg24__lib_1_1carried__bool__vector.html">carried_bool_vector</a> &lt;Type, indexer, <a class="el" href="structg24__lib_1_1default__memory__manager.html">default_memory_manager</a>&lt;Type, indexer&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="classg24__lib_1_1carried__bool__vector.html" title="A container that holds an array of booleans in a given memory context in a space efficient way,...">g24_lib::carried_bool_vector</a></code> that holds the booleans in the usual, CPU-addressable memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in whose bitwise representation the booleans will be packed (the <em>blocks</em>).</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="carried__bool__vector_8h_source.html#l00794">794</a> of file <a class="el" href="carried__bool__vector_8h_source.html">carried_bool_vector.h</a>.</p>

</div>
</div>
<a id="ae68e628801b623856bb60a4deaad85c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68e628801b623856bb60a4deaad85c4">&#9670;&nbsp;</a></span>cpu_object</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#ae68e628801b623856bb60a4deaad85c4">g24_lib::cpu_object</a> = typedef <a class="el" href="classg24__lib_1_1managed__object.html">managed_object</a> &lt;Type, num, <a class="el" href="structg24__lib_1_1default__memory__manager.html">default_memory_manager</a>&lt;Type, num&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="classg24__lib_1_1managed__object.html" title="A container that holds an object in a given memory context.">g24_lib::managed_object</a></code> that holds the object in the usual, CPU-addressable memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the object.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="managed__object_8h_source.html#l00630">630</a> of file <a class="el" href="managed__object_8h_source.html">managed_object.h</a>.</p>

</div>
</div>
<a id="afe6d7f7fb95ec19aa2ad09dc0561c4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6d7f7fb95ec19aa2ad09dc0561c4a5">&#9670;&nbsp;</a></span>cpu_split_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#afe6d7f7fb95ec19aa2ad09dc0561c4a5">g24_lib::cpu_split_array</a> = typedef <a class="el" href="structg24__lib_1_1split__member__array.html">split_member_array</a> &lt;Type, num, <a class="el" href="structg24__lib_1_1default__memory__manager.html">default_memory_manager</a>, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="structg24__lib_1_1split__member__array.html" title="A container that stores the different members of a struct that can undergo compile time reflection th...">g24_lib::split_member_array</a></code> that holds the array in the usual, CPU-addressable memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in the array.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="split__array_8h_source.html#l01251">1251</a> of file <a class="el" href="split__array_8h_source.html">split_array.h</a>.</p>

</div>
</div>
<a id="ab811624341877094f0d0786c95f59178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab811624341877094f0d0786c95f59178">&#9670;&nbsp;</a></span>cuda_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#ab811624341877094f0d0786c95f59178">g24_lib::cuda_array</a> = typedef <a class="el" href="classg24__lib_1_1simple__array.html">simple_array</a> &lt;Type, num, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>&lt;Type, num&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="classg24__lib_1_1simple__array.html" title="A container that holds an array of objects in a given memory context.">g24_lib::simple_array</a></code> that holds the array in the memory of a <code>CUDA-enabled</code> GPU. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in the array.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simple__array_8h_source.html#l00866">866</a> of file <a class="el" href="simple__array_8h_source.html">simple_array.h</a>.</p>

</div>
</div>
<a id="ae41af5529f2c640054299e5eae419bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41af5529f2c640054299e5eae419bb5">&#9670;&nbsp;</a></span>cuda_bool_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#ae41af5529f2c640054299e5eae419bb5">g24_lib::cuda_bool_vector</a> = typedef <a class="el" href="classg24__lib_1_1carried__bool__vector.html">carried_bool_vector</a> &lt;Type, indexer, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>&lt;Type, indexer&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="classg24__lib_1_1carried__bool__vector.html" title="A container that holds an array of booleans in a given memory context in a space efficient way,...">g24_lib::carried_bool_vector</a></code> that holds the booleans in the memory of a <code>CUDA-enabled</code> GPU. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in whose bitwise representation the booleans will be packed (the <em>blocks</em>).</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="carried__bool__vector_8h_source.html#l00807">807</a> of file <a class="el" href="carried__bool__vector_8h_source.html">carried_bool_vector.h</a>.</p>

</div>
</div>
<a id="ad2c20ed28f8476d1475c28167bba8c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c20ed28f8476d1475c28167bba8c76">&#9670;&nbsp;</a></span>cuda_kernel_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#ad2c20ed28f8476d1475c28167bba8c76">g24_lib::cuda_kernel_array</a> = typedef <a class="el" href="classg24__lib_1_1simple__array.html">simple_array</a> &lt;Type, num, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>&lt;Type, num&gt;, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The appropriate way to pass a <code><a class="el" href="classg24__lib_1_1simple__array.html" title="A container that holds an array of objects in a given memory context.">g24_lib::simple_array</a></code> into a <code>CUDA</code> kernel. Will copy the pointer if the memory already resides in the GPU, so the original array will be addressed and will experience any changes dictated by the kernel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in the array.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Since there is <code><a class="el" href="namespaceg24__lib.html#a55cd110ba53c6a6a51bced0cf1fac427" title="Provides a form of obj that is suitable to be operated on in a CUDA kernel.">g24_lib::to_CUDA</a></code> (and all the abstractions in <code>g24_lib::parallelism</code>), it should no longer be necessary to explicitly convert to this class to pass things into a kernel. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simple__array_8h_source.html#l00884">884</a> of file <a class="el" href="simple__array_8h_source.html">simple_array.h</a>.</p>

</div>
</div>
<a id="a725368462b34139620db9424f256eb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725368462b34139620db9424f256eb7b">&#9670;&nbsp;</a></span>cuda_kernel_bool_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a725368462b34139620db9424f256eb7b">g24_lib::cuda_kernel_bool_vector</a> = typedef <a class="el" href="classg24__lib_1_1carried__bool__vector.html">carried_bool_vector</a> &lt;Type, indexer, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>&lt;Type, indexer&gt;, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The appropriate way to pass a <code><a class="el" href="classg24__lib_1_1carried__bool__vector.html" title="A container that holds an array of booleans in a given memory context in a space efficient way,...">g24_lib::carried_bool_vector</a></code> into a <code>CUDA</code> kernel. Will copy a pointer if the memory already resides in the GPU, so the original array will be addressed and will experience any changes dictated by the kernel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in whose bitwise representation the booleans will be packed (the <em>blocks</em>).</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="carried__bool__vector_8h_source.html#l00821">821</a> of file <a class="el" href="carried__bool__vector_8h_source.html">carried_bool_vector.h</a>.</p>

</div>
</div>
<a id="a3d9b9b9e48f08f6be83be3cb8bddc120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9b9b9e48f08f6be83be3cb8bddc120">&#9670;&nbsp;</a></span>cuda_kernel_object</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a3d9b9b9e48f08f6be83be3cb8bddc120">g24_lib::cuda_kernel_object</a> = typedef <a class="el" href="classg24__lib_1_1managed__object.html">managed_object</a> &lt;Type, num, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>&lt;Type, num&gt;, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The appropriate way to pass a <code><a class="el" href="classg24__lib_1_1managed__object.html" title="A container that holds an object in a given memory context.">g24_lib::managed_object</a></code> into a <code>CUDA</code> kernel. Will copy the pointer if the memory already resides in the GPU, so the original array will be addressed and will experience any changes dictated by the kernel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the object.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Since there is <code><a class="el" href="namespaceg24__lib.html#a55cd110ba53c6a6a51bced0cf1fac427" title="Provides a form of obj that is suitable to be operated on in a CUDA kernel.">g24_lib::to_CUDA</a></code> (and all the abstractions in <code>g24_lib::parallelism</code>), it should no longer be necessary to explicitly convert to this class to pass things into a kernel. </dd></dl>

<p class="definition">Definition at line <a class="el" href="managed__object_8h_source.html#l00659">659</a> of file <a class="el" href="managed__object_8h_source.html">managed_object.h</a>.</p>

</div>
</div>
<a id="a6f9b2aadb104111ef615c0c23445b72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9b2aadb104111ef615c0c23445b72f">&#9670;&nbsp;</a></span>cuda_kernel_split_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a6f9b2aadb104111ef615c0c23445b72f">g24_lib::cuda_kernel_split_array</a> = typedef <a class="el" href="structg24__lib_1_1split__member__array.html">split_member_array</a> &lt;Type, num, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The appropriate way to pass a <code><a class="el" href="structg24__lib_1_1split__member__array.html" title="A container that stores the different members of a struct that can undergo compile time reflection th...">g24_lib::split_member_array</a></code> into a <code>CUDA</code> kernel. Will copy the pointer if the memory already resides in the GPU, so the original array will be addressed and will experience any changes dictated by the kernel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in the array.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Since there is <code><a class="el" href="namespaceg24__lib.html#a55cd110ba53c6a6a51bced0cf1fac427" title="Provides a form of obj that is suitable to be operated on in a CUDA kernel.">g24_lib::to_CUDA</a></code> (and all the abstractions in <code><a class="el" href="namespaceg24__lib_1_1_parallelism.html" title="The different forms of parallelism supported by the library are here.">g24_lib::Parallelism</a></code>), it should no longer be necessary to explicitly convert to this class to pass things into a kernel. </dd></dl>

<p class="definition">Definition at line <a class="el" href="split__array_8h_source.html#l01281">1281</a> of file <a class="el" href="split__array_8h_source.html">split_array.h</a>.</p>

</div>
</div>
<a id="af9e042461ff360a1d44780ed18f84e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e042461ff360a1d44780ed18f84e20">&#9670;&nbsp;</a></span>cuda_object</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#af9e042461ff360a1d44780ed18f84e20">g24_lib::cuda_object</a> = typedef <a class="el" href="classg24__lib_1_1managed__object.html">managed_object</a> &lt;Type, num, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>&lt;Type, num&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="classg24__lib_1_1managed__object.html" title="A container that holds an object in a given memory context.">g24_lib::managed_object</a></code> that holds the object in the memory of a <code>CUDA-enabled</code> GPU. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the object.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="managed__object_8h_source.html#l00642">642</a> of file <a class="el" href="managed__object_8h_source.html">managed_object.h</a>.</p>

</div>
</div>
<a id="a69a44df94474592b8b103a57e1ad195b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a44df94474592b8b103a57e1ad195b">&#9670;&nbsp;</a></span>cuda_split_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a69a44df94474592b8b103a57e1ad195b">g24_lib::cuda_split_array</a> = typedef <a class="el" href="structg24__lib_1_1split__member__array.html">split_member_array</a> &lt;Type, num, <a class="el" href="structg24__lib_1_1_c_u_d_a__memory__manager.html">CUDA_memory_manager</a>, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="structg24__lib_1_1split__member__array.html" title="A container that stores the different members of a struct that can undergo compile time reflection th...">g24_lib::split_member_array</a></code> that holds the array in the memory of a <code>CUDA-enabled</code> GPU. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in the array.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="split__array_8h_source.html#l01263">1263</a> of file <a class="el" href="split__array_8h_source.html">split_array.h</a>.</p>

</div>
</div>
<a id="a50a0cf1c5325fb5405f215e22c8bdde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a0cf1c5325fb5405f215e22c8bdde4">&#9670;&nbsp;</a></span>indexer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a50a0cf1c5325fb5405f215e22c8bdde4">g24_lib::indexer_type</a> = typedef typename internals::container_checks&lt;std::decay_t&lt;C&gt; &gt;::indexer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields the indexer type of a container-like class, or void if the class isn't a container. </p>
<p>The indexer type is obtained either from a member <code>typedef</code> for <code>indexer_type</code>, a member <code>typedef</code> for <code>size_type</code> or the return type of a <code>size()</code> member function.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When using this, one should try to ensure it is not actually <code>void</code>, or else several template instantiation errors might ensue. </dd></dl>

<p class="definition">Definition at line <a class="el" href="general__helpers_8h_source.html#l00352">352</a> of file <a class="el" href="general__helpers_8h_source.html">general_helpers.h</a>.</p>

</div>
</div>
<a id="a0a0f2bbfac983937a3f7370fe4a27b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0f2bbfac983937a3f7370fe4a27b0b">&#9670;&nbsp;</a></span>managed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a0a0f2bbfac983937a3f7370fe4a27b0b">g24_lib::managed</a> = typedef <a class="el" href="classg24__lib_1_1managed__object.html">managed_object</a> &lt;Type, num, <a class="el" href="namespaceg24__lib_1_1_memory_context.html#ad7443412ad1c5a53abdc4b78e94231c3">MemoryContext::current_manager</a>&lt;Type, num&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="classg24__lib_1_1managed__object.html" title="A container that holds an object in a given memory context.">g24_lib::managed_object</a></code> that holds the object in the memory appropriate for the current context. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the object.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="managed__object_8h_source.html#l00618">618</a> of file <a class="el" href="managed__object_8h_source.html">managed_object.h</a>.</p>

</div>
</div>
<a id="a97d36a0633ce92a58b17b2480cde0cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d36a0633ce92a58b17b2480cde0cb6">&#9670;&nbsp;</a></span>managed_parallel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class parallel , class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a97d36a0633ce92a58b17b2480cde0cb6">g24_lib::managed_parallel</a> = typedef <a class="el" href="classg24__lib_1_1managed__object.html">managed_object</a> &lt;Type, num, typename parallel::template memory_manager&lt;Type, num&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="classg24__lib_1_1managed__object.html" title="A container that holds an object in a given memory context.">g24_lib::managed_object</a></code> that holds the object in a way that is appropriate for a specific type of parallelism. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the object.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
    <tr><td class="paramname">parallel</td><td>A type of parallelism.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>.</dd>
<dd>
<code>parallel</code> must be a valid type of parallelism, that is, it must satisfy <code><a class="el" href="namespaceg24__lib.html#a26cb719a58a528fd6413386435a5eb6b" title="Checks if parallel is a valid form of parallelism.">g24_lib::is_parallelism</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="managed__object_8h_source.html#l00678">678</a> of file <a class="el" href="managed__object_8h_source.html">managed_object.h</a>.</p>

</div>
</div>
<a id="abe5a04771b0e792815e9d35b54e32746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5a04771b0e792815e9d35b54e32746">&#9670;&nbsp;</a></span>signed_integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;g24_lib::Definitions::default_unsigned_indexer size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#abe5a04771b0e792815e9d35b54e32746">g24_lib::signed_integer</a> = typedef typename <a class="el" href="structg24__lib_1_1internals_1_1any__sized__int.html">internals::any_sized_int</a>&lt;size, true&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a signed integer type with a specific number of bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">size</td><td>The desired number of bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="structg24__lib_1_1internals_1_1any__sized__int.html" title="Represents an integer type with a specific number of bytes.">g24_lib::internals::any_sized_int</a> for details. </p>

<p class="definition">Definition at line <a class="el" href="compile__time__utilities_8h_source.html#l00625">625</a> of file <a class="el" href="compile__time__utilities_8h_source.html">compile_time_utilities.h</a>.</p>

</div>
</div>
<a id="ae0b02ea968f04de5bab62a20125ce7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b02ea968f04de5bab62a20125ce7a0">&#9670;&nbsp;</a></span>split_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#ae0b02ea968f04de5bab62a20125ce7a0">g24_lib::split_array</a> = typedef <a class="el" href="structg24__lib_1_1split__member__array.html">split_member_array</a> &lt;Type, num, <a class="el" href="namespaceg24__lib_1_1_memory_context.html#ad7443412ad1c5a53abdc4b78e94231c3">MemoryContext::current_manager</a>, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="structg24__lib_1_1split__member__array.html" title="A container that stores the different members of a struct that can undergo compile time reflection th...">g24_lib::split_member_array</a></code> that holds the array in the memory appropriate for the current context. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in the array.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="split__array_8h_source.html#l01238">1238</a> of file <a class="el" href="split__array_8h_source.html">split_array.h</a>.</p>

</div>
</div>
<a id="ad9fecbb6037aa8e21bbbf5bfe05e556b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fecbb6037aa8e21bbbf5bfe05e556b">&#9670;&nbsp;</a></span>split_array_parallel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class parallel , class Type , class num  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#ad9fecbb6037aa8e21bbbf5bfe05e556b">g24_lib::split_array_parallel</a> = typedef <a class="el" href="structg24__lib_1_1split__member__array.html">split_member_array</a> &lt;Type, num, parallel::template memory_manager, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="structg24__lib_1_1split__member__array.html" title="A container that stores the different members of a struct that can undergo compile time reflection th...">g24_lib::split_member_array</a></code> that holds the array in a way that is appropriate for a specific type of parallelism. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the objects in the array.</td></tr>
    <tr><td class="paramname">num</td><td>A type that is appropriate to hold sizes of objects.</td></tr>
    <tr><td class="paramname">parallel</td><td>A type of parallelism.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#a3eddc9ae1c70c4a1fd4ea08e81ce7cb6">g24_lib::Definitions::default_unsigned_indexer</a>.</dd>
<dd>
<code>parallel</code> must be a valid type of parallelism, that is, it must satisfy <code><a class="el" href="namespaceg24__lib.html#a26cb719a58a528fd6413386435a5eb6b" title="Checks if parallel is a valid form of parallelism.">g24_lib::is_parallelism</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="split__array_8h_source.html#l01300">1300</a> of file <a class="el" href="split__array_8h_source.html">split_array.h</a>.</p>

</div>
</div>
<a id="a0f23ede94e5a8beeac8997274c58c293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f23ede94e5a8beeac8997274c58c293">&#9670;&nbsp;</a></span>to_CUDA_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a0f23ede94e5a8beeac8997274c58c293">g24_lib::to_CUDA_t</a> = typedef decltype(<a class="el" href="namespaceg24__lib.html#a55cd110ba53c6a6a51bced0cf1fac427">to_CUDA</a>(std::declval&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the type of the CUDA-compatible version of <code>T</code>. </p>

<p class="definition">Definition at line <a class="el" href="_c_u_d_a__utilities_8h_source.html#l00143">143</a> of file <a class="el" href="_c_u_d_a__utilities_8h_source.html">CUDA_utilities.h</a>.</p>

</div>
</div>
<a id="ac272351f0f0b8eeb33bc02c484450f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac272351f0f0b8eeb33bc02c484450f96">&#9670;&nbsp;</a></span>unsigned_integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;g24_lib::Definitions::default_unsigned_indexer size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#ac272351f0f0b8eeb33bc02c484450f96">g24_lib::unsigned_integer</a> = typedef typename <a class="el" href="structg24__lib_1_1internals_1_1any__sized__int.html">internals::any_sized_int</a>&lt;size, false&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents an unsigned integer type with a specific number of bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">size</td><td>The desired number of bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="structg24__lib_1_1internals_1_1any__sized__int.html" title="Represents an integer type with a specific number of bytes.">g24_lib::internals::any_sized_int</a> for details. </p>

<p class="definition">Definition at line <a class="el" href="compile__time__utilities_8h_source.html#l00635">635</a> of file <a class="el" href="compile__time__utilities_8h_source.html">compile_time_utilities.h</a>.</p>

</div>
</div>
<a id="a90b455b207b88a2b2fad31a2bd9f0ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b455b207b88a2b2fad31a2bd9f0ab4">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceg24__lib.html#a90b455b207b88a2b2fad31a2bd9f0ab4">g24_lib::value_type</a> = typedef typename internals::container_checks&lt;std::decay_t&lt;C&gt; &gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields the value type of a container-like class, or void if the class isn't a container. </p>
<p>The value type is obtained either from a member <code>typedef</code> for <code>value_type</code> or the return type of <code>operator []</code> (after removing references).</p>
<dl class="section remark"><dt>Remarks</dt><dd>When using this, one should try to ensure it is not actually <code>void</code>, or else several template instantiation errors might ensue. </dd></dl>

<p class="definition">Definition at line <a class="el" href="general__helpers_8h_source.html#l00365">365</a> of file <a class="el" href="general__helpers_8h_source.html">general_helpers.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1c69dc6164b980f081d0ae62fc91b5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c69dc6164b980f081d0ae62fc91b5f0">&#9670;&nbsp;</a></span>ask_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt;Type&gt; g24_lib::ask_comp </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reduc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asks the user for a <a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a> number and returns it. If <code>reduc</code> is true, if the complex appears to be in the polar form, the argument is read as a fraction of pi. </p>
<p>The possible inputs are: <code>a + i b</code>, <code>a - i b</code>, <code>a + b i</code>, <code>a - bi</code>, <code>b i + a</code>, <code>b i</code>, a, <code>rho cis theta</code>, <code>rho pol theta</code>, ignoring whitespace and capitalization in what regards to the plus or minus signs and the imaginary unit.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Since the standard library already implements <code>std::complex</code>, <code><a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a></code> might be more than a bit superfluous unless <code>CUDA</code> interoperatability is significant... </dd></dl>

<p class="definition">Definition at line <a class="el" href="comp_8h_source.html#l00716">716</a> of file <a class="el" href="comp_8h_source.html">comp.h</a>.</p>

</div>
</div>
<a id="a7cda0ddc581b69bbc6d6e8b4b5278aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cda0ddc581b69bbc6d6e8b4b5278aeb">&#9670;&nbsp;</a></span>binary_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void g24_lib::binary_input </td>
          <td>(</td>
          <td class="paramtype">stream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inputs an object in binary mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the object being input.</td></tr>
    <tr><td class="paramname">stream</td><td>Something akin to an <code>istream</code>, to which bytes can be input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">In</td><td>case an input error is encountered, uses <a class="el" href="namespaceg24__lib_1_1exceptions.html#a6b5d01ac0547957734140d32e3ff9b5c" title="Exception thrown when an error is encountered during input.">g24_lib::exceptions::throw_exception</a> to possibly throw a <a class="el" href="structg24__lib_1_1exceptions_1_1input__error.html" title="Exception thrown when an error is encountered during input.">g24_lib::exceptions::input_error</a>. The input object <code>in</code> may be in an invalid state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The behaviour of this function for user defined classes may be more simply "overloaded" by providing a <code>binary_input</code> member function that takes <code>s</code> as argument, which will be used whenever available.</dd>
<dd>
For classes that satisfy <code>std::is_trivially_copyable</code> (which are defined by the standard as able to be serialized in a binary format), the byte sequence that corresponds to the object <code>in</code> is read from the stream.</dd>
<dd>
For classes that do not have a <code>binary_input</code> member function or are not trivially copyable, a <code><a class="el" href="structg24__lib_1_1flat__imitation__struct.html" title="Constructs a struct that has every scalar member of all the members of a class (at all levels of incl...">g24_lib::flat_imitation_struct</a></code> is constructed, every member is read from the stream as a sequence of bytes and the new value of <code>in</code> will come from a new <code>T</code> constructed from the imitation struct.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>stream</code> must have a valid member function with signature <code>void read(char *dest, const size_t n)</code> that reads <code>n</code> bytes starting from the memory location pointed by <code>origin</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>As with all binary serialization procedures, the expected input will be dependent on the endianness of the system in use, the sizes of the different native types and the padding added to trivially copyable classes. For the same program running on the same system, there will be no problems, but portability may be a significant concern. <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="serialization__helpers_8h_source.html#l00408">408</a> of file <a class="el" href="serialization__helpers_8h_source.html">serialization_helpers.h</a>.</p>

</div>
</div>
<a id="a14cefdfa1b2f7d066e4ba87aa99cdedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14cefdfa1b2f7d066e4ba87aa99cdedd">&#9670;&nbsp;</a></span>binary_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void g24_lib::binary_output </td>
          <td>(</td>
          <td class="paramtype">stream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs an object in binary mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the object being output.</td></tr>
    <tr><td class="paramname">stream</td><td>Something akin to an <code>ostream</code>, to which bytes can be output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">In</td><td>case an output error is encountered, uses <a class="el" href="namespaceg24__lib_1_1exceptions.html#a6b5d01ac0547957734140d32e3ff9b5c" title="Exception thrown when an error is encountered during input.">g24_lib::exceptions::throw_exception</a> to possibly throw a <a class="el" href="structg24__lib_1_1exceptions_1_1output__error.html" title="Exception thrown when an error is encountered during output.">g24_lib::exceptions::output_error</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The behaviour of this function for user defined classes may be more simply "overloaded" by providing a <code>binary_output</code> member function that takes <code>s</code> as argument, which will be used whenever available.</dd>
<dd>
For classes that satisfy <code>std::is_trivially_copyable</code> (which are defined by the standard as able to be serialized in a binary format), the byte sequence that corresponds to the object <code>out</code> is written to the stream.</dd>
<dd>
For classes that do not have a <code>binary_output</code> member function or are not trivially copyable, a <code><a class="el" href="structg24__lib_1_1flat__imitation__struct.html" title="Constructs a struct that has every scalar member of all the members of a class (at all levels of incl...">g24_lib::flat_imitation_struct</a></code> is constructed and every member is written to the stream as a sequence of bytes.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>stream</code> must have a valid member function with signature <code>void write(const char *origin, const size_t n)</code> that writes <code>n</code> bytes starting from the memory location pointed by <code>origin</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>As with all binary serialization procedures, the output will be dependent on the endianness of the system in use, the sizes of the different native types and the padding added to trivially copyable classes. For the same program running on the same system, there will be no problems, but portability may be a significant concern. <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="serialization__helpers_8h_source.html#l00351">351</a> of file <a class="el" href="serialization__helpers_8h_source.html">serialization_helpers.h</a>.</p>

</div>
</div>
<a id="a5517c8b80dd7e62bc9d9154ca766bcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5517c8b80dd7e62bc9d9154ca766bcbe">&#9670;&nbsp;</a></span>butcher_entry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class factorT , factorT num, factorT denom, class ... frac_gens&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::butcher_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structg24__lib_1_1constexpr__fraction.html">constexpr_fraction</a>&lt; factorT, num, denom &gt;&#160;</td>
          <td class="paramname"><em>eval_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const frac_gens ...&#160;</td>
          <td class="paramname"><em>fracs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">\brief Returns an entry of a Butcher tableau.

\param eval_t A `g24_lib::constexpr_fraction` that holds the evaluation time of this entry.

\param fracs A series of `g24_lib::constexpr_fraction` that hold the coefficients of previous evaluations.

\remark For a Butcher entry like `a/b | c/d e/f g/h ...`, one could do something like:
</pre> <div class="fragment"><div class="line"><span class="keyword">using</span> factorT = ...;</div>
<div class="line"><span class="keyword">template</span> &lt;factorT num, factorT denom&gt; <span class="keyword">using</span> <a class="code" href="namespaceg24__lib_1_1_runge_kutta_methods.html#add32e2f78720bc709db9f86c9ddf64d5">frac</a> = <a class="code" href="structg24__lib_1_1constexpr__fraction.html">g24_lib::constexpr_fraction&lt;factorT, num, denom&gt;</a>;</div>
<div class="line"><a class="code" href="namespaceg24__lib.html#a5517c8b80dd7e62bc9d9154ca766bcbe">butcher_entry</a>(frac&lt;a, b&gt;, frac&lt;c, d&gt;, frac&lt;e, f&gt;, frac&lt;g, h&gt;, ...);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="temporal__evolver_8h_source.html#l00474">474</a> of file <a class="el" href="temporal__evolver_8h_source.html">temporal_evolver.h</a>.</p>

</div>
</div>
<a id="a60e8e922b0d8b6e3214cec2d356075a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e8e922b0d8b6e3214cec2d356075a1">&#9670;&nbsp;</a></span>butcher_final()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class factorT , factorT num, factorT denom, class ... frac_gens&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::butcher_final </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structg24__lib_1_1constexpr__fraction.html">constexpr_fraction</a>&lt; factorT, num, denom &gt;&#160;</td>
          <td class="paramname"><em>frac1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const frac_gens ...&#160;</td>
          <td class="paramname"><em>fracs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">\brief Returns a final entry of a Butcher tableau.

\param frac1 A `g24_lib::constexpr_fraction` that holds the coefficient of the evaluation at `t`.

\param fracs A series of `g24_lib::constexpr_fraction` that hold the coefficients of previous evaluations.

\remark For a Butcher final entry like `  | a/b c/d e/f g/h ...`, one could do something like:
</pre> <div class="fragment"><div class="line"><span class="keyword">using</span> factorT = ...;</div>
<div class="line"><span class="keyword">template</span> &lt;factorT num, factorT denom&gt; <span class="keyword">using</span> <a class="code" href="namespaceg24__lib_1_1_runge_kutta_methods.html#add32e2f78720bc709db9f86c9ddf64d5">frac</a> = <a class="code" href="structg24__lib_1_1constexpr__fraction.html">g24_lib::constexpr_fraction&lt;factorT, num, denom&gt;</a>;</div>
<div class="line">butcher_final_entry(frac&lt;a, b&gt;, frac&lt;c, d&gt;, frac&lt;e, f&gt;, frac&lt;g, h&gt;, ...);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="temporal__evolver_8h_source.html#l00494">494</a> of file <a class="el" href="temporal__evolver_8h_source.html">temporal_evolver.h</a>.</p>

</div>
</div>
<a id="a3591d08d7d5be4ba64e61df42483223e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3591d08d7d5be4ba64e61df42483223e">&#9670;&nbsp;</a></span>compile_time_type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::string_view g24_lib::compile_time_type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a compile-time type name based on a non-portable trick involving compiler specific macros. </p>
<p>This is taken from <a href="https://stackoverflow.com/a/56766138">an answer</a> from user <em>einpoklum</em> of Stack Overflow, which, itself, builds on work by Howard Hinnant.</p>
<dl class="section warning"><dt>Warning</dt><dd>This uses a non-portable trick involving macros that some compilers define to ease debug output of function signatures. It currently only gives correct results with Clang, GCC/G++ and MSVC, with all other compilers yielding "`unsupported compiler for compile time type name`".</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Possibly figure out a way to extend this for other compilers? It is very low priority since the three major compilers are already supported and this is only used for error messages in the serialization functions, but the rest of the library strives for generality and so should this function. (Once again, proper reflection might alleviate this, or, at the very least, a standard defined way to get compile-time type names as strings...).</dd></dl>

<p class="definition">Definition at line <a class="el" href="compile__time__utilities_8h_source.html#l01220">1220</a> of file <a class="el" href="compile__time__utilities_8h_source.html">compile_time_utilities.h</a>.</p>

</div>
</div>
<a id="a8bec1de2c8b081866513d9a9dffb44e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bec1de2c8b081866513d9a9dffb44e6">&#9670;&nbsp;</a></span>curl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tarr_vec , class ndview_like , class cellsizeT , class indexer  = g24_lib::Definitions::default_signed_indexer, class factorT  = g24_lib::Definitions::default_floating_point&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::curl </td>
          <td>(</td>
          <td class="paramtype">const Tarr_vec &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ndview_like &amp;&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cellsizeT &amp;&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the curl of <code>arr</code> at point <code>elem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array to be differentiated.</td></tr>
    <tr><td class="paramname">elem</td><td>The element of the array where the derivative is meant to be computed.</td></tr>
    <tr><td class="paramname">nd</td><td>The <code><a class="el" href="classg24__lib_1_1ndview.html" title="Allows indexing of multidimensional arrays.">g24_lib::ndview</a></code> that expresses the multidimensional properties of the array.</td></tr>
    <tr><td class="paramname">cs</td><td>The cell size/grid spacing to use.</td></tr>
    <tr><td class="paramname">accuracy</td><td>The accuracy with which to calculate the derivative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>It is assumed that <code>arr</code> is a tridimensional array holding tridimensional vectors; no generalizations of the curl are considered for simplicity's sake.</dd>
<dd>
<code>indexer</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#afd5834e3afad85414bee808e28a49c52">g24_lib::Definitions::default_signed_indexer</a> (for compatibility with ndview).</dd>
<dd>
<code>factor_type</code> must support multiplications and divisions with itself (and with the elements of the array whose derivatives will be evaluated). It does not need to be a floating point type since the coefficients are stored essentially as rational numbers. </dd></dl>

<p class="definition">Definition at line <a class="el" href="derivatives_8h_source.html#l00452">452</a> of file <a class="el" href="derivatives_8h_source.html">derivatives.h</a>.</p>

</div>
</div>
<a id="acac430c3b4107b5305fe8c44d8a25eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac430c3b4107b5305fe8c44d8a25eb1">&#9670;&nbsp;</a></span>defer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , bool by_value = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::defer </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defers the evaluation of most overloadable operators on <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The type of the object upon which the operators will be deferred.</td></tr>
    <tr><td class="paramname">by_value</td><td>If <code>true</code>, the object is stored by value rather than by reference. Useful mostly for <code>CUDA</code> interoperatability, or other situations where references may be invalidated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The object to be deferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The deferred operators correspond to binary <code>x + y</code>, <code>x - y</code>, <code>x * y</code>, <code>x / y</code>, <code>x % y</code>, <code>x ^ y</code>, <code>x &amp; y</code>, <code>x | y</code>, <code>x &lt; y</code>, <code>x &lt;= y</code>, <code>x &gt; y</code>, <code>x &gt;= y</code>, <code>x &lt;&lt; y</code>, <code>x &gt;&gt; y</code>, <code>x == y</code>, <code>x != y</code>, unary <code>+x</code>, <code>-x</code>, <code>~x</code>, <code>!x</code> and both pre and post increment and decrement (<code>++x</code>, <code>x++</code>, <code>--x</code> and <code>x--</code>), as well as array access (<code>x[y]</code>).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Due to the type-based nature of this deferred evaluation, the use of the <code>auto</code> keyword is strongly reccommended. Similarly, to ensure function parameters that may be deferred objects do work properly, they should be templated.</dd>
<dd>
The author acknowledges this could be partly alleviated if one were to employ virtual functions and simply refer to a base object,</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Since the <code>&lt;&lt;</code> operator is also deferred, if one wishes to output a deferred object to a stream, one should either explicitly cast it to an appropriate type or call its <code>execute()</code> method. (Which, despite its name, will not entail any harm to any living being.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="deferred__ops_8h_source.html#l00160">160</a> of file <a class="el" href="deferred__ops_8h_source.html">deferred_ops.h</a>.</p>

</div>
</div>
<a id="ade6ba1f821989a3d8d4523af275bd9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6ba1f821989a3d8d4523af275bd9c1">&#9670;&nbsp;</a></span>defer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , bool by_value = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::defer </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defers the evaluation of most overloadable operators on <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The type of the object upon which the operators will be deferred.</td></tr>
    <tr><td class="paramname">by_value</td><td>If <code>true</code>, the object is stored by value rather than by reference. Useful mostly for <code>CUDA</code> interoperatability, or other situations where references may be invalidated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The object to be deferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The deferred operators correspond to binary <code>x + y</code>, <code>x - y</code>, <code>x * y</code>, <code>x / y</code>, <code>x % y</code>, <code>x ^ y</code>, <code>x &amp; y</code>, <code>x | y</code>, <code>x &lt; y</code>, <code>x &lt;= y</code>, <code>x &gt; y</code>, <code>x &gt;= y</code>, <code>x &lt;&lt; y</code>, <code>x &gt;&gt; y</code>, <code>x == y</code>, <code>x != y</code>, unary <code>+x</code>, <code>-x</code>, <code>~x</code>, <code>!x</code> and both pre and post increment and decrement (<code>++x</code>, <code>x++</code>, <code>--x</code> and <code>x--</code>), as well as array access (<code>x[y]</code>).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Due to the type-based nature of this deferred evaluation, the use of the <code>auto</code> keyword is strongly reccommended. Similarly, to ensure function parameters that may be deferred objects do work properly, they should be templated.</dd>
<dd>
The author acknowledges this could be partly alleviated if one were to employ virtual functions and simply refer to a base object,</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Since the <code>&lt;&lt;</code> operator is also deferred, if one wishes to output a deferred object to a stream, one should either explicitly cast it to an appropriate type or call its <code>execute()</code> method. (Which, despite its name, will not entail any harm to any living being.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="deferred__ops_8h_source.html#l00107">107</a> of file <a class="el" href="deferred__ops_8h_source.html">deferred_ops.h</a>.</p>

</div>
</div>
<a id="a82bc5f4f4c2af077d418ecee738b76b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82bc5f4f4c2af077d418ecee738b76b4">&#9670;&nbsp;</a></span>derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tarr , class ndview_like , class cellsizeT , class indexer  = g24_lib::Definitions::default_signed_indexer, class factorT  = g24_lib::Definitions::default_floating_point&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::derivative </td>
          <td>(</td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tarr &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ndview_like &amp;&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cellsizeT &amp;&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>order</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a derivative along dimension <code>dimension</code> of an array with multidimensional properties given by <code>nd</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>The dimension along which to take the derivative.</td></tr>
    <tr><td class="paramname">arr</td><td>The array to be differentiated.</td></tr>
    <tr><td class="paramname">elem</td><td>The element of the array where the derivative is meant to be computed.</td></tr>
    <tr><td class="paramname">nd</td><td>The <code><a class="el" href="classg24__lib_1_1ndview.html" title="Allows indexing of multidimensional arrays.">g24_lib::ndview</a></code> that expresses the multidimensional properties of the array.</td></tr>
    <tr><td class="paramname">cs</td><td>The cell size/grid spacing to use.</td></tr>
    <tr><td class="paramname">order</td><td>The order of the derivative.</td></tr>
    <tr><td class="paramname">accuracy</td><td>The accuracy with which to calculate the derivative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>indexer</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#afd5834e3afad85414bee808e28a49c52">g24_lib::Definitions::default_signed_indexer</a> (for compatibility with ndview).</dd>
<dd>
<code>factor_type</code> must support multiplications and divisions with itself (and with the elements of the array whose derivatives will be evaluated). It does not need to be a floating point type since the coefficients are stored essentially as rational numbers. </dd></dl>

<p class="definition">Definition at line <a class="el" href="derivatives_8h_source.html#l00331">331</a> of file <a class="el" href="derivatives_8h_source.html">derivatives.h</a>.</p>

</div>
</div>
<a id="aba16e986d4cc5514774c378585c5a8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba16e986d4cc5514774c378585c5a8ec">&#9670;&nbsp;</a></span>divergence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tarr_vec , class ndview_like , class cellsizeT , class indexer  = g24_lib::Definitions::default_signed_indexer, class factorT  = g24_lib::Definitions::default_floating_point&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::divergence </td>
          <td>(</td>
          <td class="paramtype">const Tarr_vec &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ndview_like &amp;&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cellsizeT &amp;&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the divergence of <code>arr</code> at point <code>elem</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array to be differentiated.</td></tr>
    <tr><td class="paramname">elem</td><td>The element of the array where the derivative is meant to be computed.</td></tr>
    <tr><td class="paramname">nd</td><td>The <code><a class="el" href="classg24__lib_1_1ndview.html" title="Allows indexing of multidimensional arrays.">g24_lib::ndview</a></code> that expresses the multidimensional properties of the array.</td></tr>
    <tr><td class="paramname">cs</td><td>The cell size/grid spacing to use.</td></tr>
    <tr><td class="paramname">accuracy</td><td>The accuracy with which to calculate the derivative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>indexer</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#afd5834e3afad85414bee808e28a49c52">g24_lib::Definitions::default_signed_indexer</a> (for compatibility with ndview).</dd>
<dd>
<code>factor_type</code> must support multiplications and divisions with itself (and with the elements of the array whose derivatives will be evaluated). It does not need to be a floating point type since the coefficients are stored essentially as rational numbers.</dd>
<dd>
<code>arr</code> must be an N-dimensional array holding N-dimensional vectors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="derivatives_8h_source.html#l00501">501</a> of file <a class="el" href="derivatives_8h_source.html">derivatives.h</a>.</p>

</div>
</div>
<a id="aadcc4defcab902e1b79de20d88f95c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcc4defcab902e1b79de20d88f95c9f">&#9670;&nbsp;</a></span>fast_read_comp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt;Type&gt; g24_lib::fast_read_comp </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reduc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a <a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a> from a stream. If <code>pol</code> is false, in cartesian form; if <code>pol</code> is true, in polar form, with the argument being as a fraction of pi if <code>reduc</code> is true or as a number in <code>]-pi, pi]</code> if <code>recuc</code> is false. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Since the standard library already implements <code>std::complex</code>, <code><a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a></code> might be more than a bit superfluous unless <code>CUDA</code> interoperatability is significant... </dd></dl>

<p class="definition">Definition at line <a class="el" href="comp_8h_source.html#l00753">753</a> of file <a class="el" href="comp_8h_source.html">comp.h</a>.</p>

</div>
</div>
<a id="a3355d33db784a10a65946963a9a7da92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3355d33db784a10a65946963a9a7da92">&#9670;&nbsp;</a></span>fast_read_comp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt;Type&gt; g24_lib::fast_read_comp </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reduc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a> read from a stream. If <code>pol</code> is false, in cartesian form; if <code>pol</code> is true, in polar form, with the argument being as a fraction of pi if <code>reduc</code> is true or as a number in <code>]-pi, pi]</code> if <code>recuc</code> is false. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Since the standard library already implements <code>std::complex</code>, <code><a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a></code> might be more than a bit superfluous unless <code>CUDA</code> interoperatability is significant... </dd></dl>

<p class="definition">Definition at line <a class="el" href="comp_8h_source.html#l00733">733</a> of file <a class="el" href="comp_8h_source.html">comp.h</a>.</p>

</div>
</div>
<a id="a47229c308fb422b5131c5cf9c9f40793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47229c308fb422b5131c5cf9c9f40793">&#9670;&nbsp;</a></span>fastpow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class base_T , class exp_T  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> base_T g24_lib::fastpow </td>
          <td>(</td>
          <td class="paramtype">const base_T &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exp_T&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expectably efficient implementation of exponentiation by integers. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>exp_T</code> must be an integer type with bitwise operations.</dd>
<dd>
<code>exp</code> must be non-negative. </dd></dl>

<p class="definition">Definition at line <a class="el" href="general__helpers_8h_source.html#l00058">58</a> of file <a class="el" href="general__helpers_8h_source.html">general_helpers.h</a>.</p>

</div>
</div>
<a id="ae992351f2d68dc94a5fca4059dfe0762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae992351f2d68dc94a5fca4059dfe0762">&#9670;&nbsp;</a></span>gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tarr , class ndview_like , class cellsizeT , class indexer  = g24_lib::Definitions::default_signed_indexer, class factorT  = g24_lib::Definitions::default_floating_point&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::gradient </td>
          <td>(</td>
          <td class="paramtype">const Tarr &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ndview_like &amp;&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cellsizeT &amp;&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the gradient of <code>arr</code> at point <code>elem</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classg24__lib_1_1fspoint.html" title="An array of Size elements of type Type. Mainly to be used as an N-dimensional vector in mathematical ...">g24_lib::fspoint</a></code> holding the same type as the elements of <code>arr</code>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is valid both for the (vectorial) gradient of a scalar field and for the (matricial, component-wise vectorial) "gradient" of a vector field (that is, the Jacobian, or its determinant, depending on how one orders rows and columns).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array to be differentiated.</td></tr>
    <tr><td class="paramname">elem</td><td>The element of the array where the derivative is meant to be computed.</td></tr>
    <tr><td class="paramname">nd</td><td>The <code><a class="el" href="classg24__lib_1_1ndview.html" title="Allows indexing of multidimensional arrays.">g24_lib::ndview</a></code> that expresses the multidimensional properties of the array.</td></tr>
    <tr><td class="paramname">cs</td><td>The cell size/grid spacing to use.</td></tr>
    <tr><td class="paramname">accuracy</td><td>The accuracy with which to calculate the derivative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>indexer</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#afd5834e3afad85414bee808e28a49c52">g24_lib::Definitions::default_signed_indexer</a> (for compatibility with ndview).</dd>
<dd>
<code>factor_type</code> must support multiplications and divisions with itself (and with the elements of the array whose derivatives will be evaluated). It does not need to be a floating point type since the coefficients are stored essentially as rational numbers. </dd></dl>

<p class="definition">Definition at line <a class="el" href="derivatives_8h_source.html#l00414">414</a> of file <a class="el" href="derivatives_8h_source.html">derivatives.h</a>.</p>

</div>
</div>
<a id="a35d6932d0994766d8f67328b72b40e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d6932d0994766d8f67328b72b40e86">&#9670;&nbsp;</a></span>interpolate_from_grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class number , class ArrT , class indexer , indexer dim, indexer skipped = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::interpolate_from_grid </td>
          <td>(</td>
          <td class="paramtype">const ArrT &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classg24__lib_1_1fspoint.html">fspoint</a>&lt; indexer, indexer, dim &gt;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classg24__lib_1_1fspoint.html">fspoint</a>&lt; number, indexer, dim &gt;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classg24__lib_1_1ndview.html">ndview</a>&lt; indexer, dim &gt;&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear interpolation in a multidimensional array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array of discretized values from which to interpolate.</td></tr>
    <tr><td class="paramname">cell</td><td>The set of indices that specifies the cell from which we want to interpolate.</td></tr>
    <tr><td class="paramname">positions</td><td>The position at which we want to interpolate expressed as a vector that contains fraction of the distance between two elements of the array in each dimension. (<code>-1 &lt; positions[i] &lt; 1</code> for <code>0 &lt;= i &lt; dim</code>)</td></tr>
    <tr><td class="paramname">view</td><td>The <code><a class="el" href="classg24__lib_1_1ndview.html" title="Allows indexing of multidimensional arrays.">g24_lib::ndview</a></code> that expresses the multidimensional structure of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This multidimensional interpolation works by repeated interpolation in every direction: we first interpolate unidimensionally in the highest dimension for the specified position, than we interpolate the results of that interpolation at relevant grid points in the second highest dimension, and so on.</dd>
<dd>
This allows immidiate generalization to any number of dimensions, with a possible (slight) decrease in performance when compared to a matricial treatment of the problem in a fixed number of dimensions. However, since the number of dimensions is known at compile-time and the interpolations are chained together also through compile-time recursion, no extra memory needs to be explicitly allocated and the optimizer might be able to produce reasonably efficient code.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">number</td><td>A type that can hold non-integer numbers. Typically floating point.</td></tr>
    <tr><td class="paramname">indexer</td><td>A type that is appropriate to hold both positive and negative offsets from a position in the array.</td></tr>
    <tr><td class="paramname">skipped</td><td>Specifies how many dimensions we are looking into. (Should not be needed for any end user, only for internal iteration of the function.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>number</code> must have addition and multiplication with the type held by the array that is being interpolated.</dd>
<dd>
<code>indexer</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#afd5834e3afad85414bee808e28a49c52">g24_lib::Definitions::default_signed_indexer</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceg24__lib.html#ab821e066d7d3ed0ac3a63c91a617d6ef" title="Linear interpolation from a unidimensional array.">g24_lib::interpolate_from_grid_1D()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="interpol_8h_source.html#l00194">194</a> of file <a class="el" href="interpol_8h_source.html">interpol.h</a>.</p>

</div>
</div>
<a id="a0c8539f8a9fcd784224145c916fd81cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8539f8a9fcd784224145c916fd81cd">&#9670;&nbsp;</a></span>interpolate_from_grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class number , class ArrT , class indexer , indexer dim, indexer skipped = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::interpolate_from_grid </td>
          <td>(</td>
          <td class="paramtype">const ArrT &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classg24__lib_1_1fspoint.html">fspoint</a>&lt; indexer, indexer, dim &gt;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classg24__lib_1_1fspoint.html">fspoint</a>&lt; number, indexer, dim &gt;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classg24__lib_1_1ndview.html">ndview</a>&lt; indexer, dim &gt;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>accuracy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polynomial interpolation in a multidimensional array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array of discretized values from which to interpolate.</td></tr>
    <tr><td class="paramname">cell</td><td>The set of indices that specifies the cell from which we want to interpolate.</td></tr>
    <tr><td class="paramname">positions</td><td>The position at which we want to interpolate expressed as a vector that contains fraction of the distance between two elements of the array in each dimension. (<code>-1 &lt; positions[i] &lt; 1</code> for <code>0 &lt;= i &lt; dim</code>)</td></tr>
    <tr><td class="paramname">view</td><td>The <code><a class="el" href="classg24__lib_1_1ndview.html" title="Allows indexing of multidimensional arrays.">g24_lib::ndview</a></code> that expresses the multidimensional structure of the array.</td></tr>
    <tr><td class="paramname">accuracy</td><td>The accuracy of the polynomial interpolation. Appropriate grid points will be selected taking the limits of the multidimensional array into account, given the information contained in <code>view</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This multidimensional interpolation works by repeated interpolation in every direction: we first interpolate unidimensionally in the highest dimension for the specified position, than we interpolate the results of that interpolation at relevant grid points in the second highest dimension, and so on.</dd>
<dd>
This allows immidiate generalization to any number of dimensions, with a possible (slight) decrease in performance when compared to a matricial treatment of the problem in a fixed number of dimensions. However, since the number of dimensions is known at compile-time and the interpolations are chained together also through compile-time recursion, no extra memory needs to be explicitly allocated and the optimizer might be able to produce reasonably efficient code.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">number</td><td>A type that can hold non-integer numbers. Typically floating point.</td></tr>
    <tr><td class="paramname">indexer</td><td>A type that is appropriate to hold both positive and negative offsets from a position in the array.</td></tr>
    <tr><td class="paramname">skipped</td><td>Specifies how many dimensions we are looking into. (Should not be needed for any end user, only for internal iteration of the function.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>number</code> must have addition and multiplication with the type held by the array that is being interpolated.</dd>
<dd>
<code>indexer</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#afd5834e3afad85414bee808e28a49c52">g24_lib::Definitions::default_signed_indexer</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceg24__lib.html#ab821e066d7d3ed0ac3a63c91a617d6ef" title="Linear interpolation from a unidimensional array.">g24_lib::interpolate_from_grid_1D()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="interpol_8h_source.html#l00270">270</a> of file <a class="el" href="interpol_8h_source.html">interpol.h</a>.</p>

</div>
</div>
<a id="ab821e066d7d3ed0ac3a63c91a617d6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab821e066d7d3ed0ac3a63c91a617d6ef">&#9670;&nbsp;</a></span>interpolate_from_grid_1D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class number , class ArrT , class indexer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::interpolate_from_grid_1D </td>
          <td>(</td>
          <td class="paramtype">const ArrT &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>separation</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear interpolation from a unidimensional array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array of discretized values from which to interpolate.</td></tr>
    <tr><td class="paramname">elem</td><td>The index of the element from which we want to interpolate.</td></tr>
    <tr><td class="paramname">position</td><td>The position at which we want to interpolate expressed as a fraction of the distance between two elements of the array. (<code>-1 &lt; position &lt; 1</code>)</td></tr>
    <tr><td class="paramname">separation</td><td>The difference in index between two consecutive elements. (Useful for each unidimensional interpolation in multidimensional grids.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Given the way linear interpolation works, it is equivalent to have <code>elem = x</code> and <code>position = y</code> (with <code>y &gt; 0</code>) or <code>elem = x + 1</code> and <code>position = y - 1</code>. For consistency reasons, we recommend the user always tries to ensure <code>position &gt; 0</code>, but the algorithm works either way.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">number</td><td>A type that can hold non-integer numbers. Typically floating point.</td></tr>
    <tr><td class="paramname">indexer</td><td>A type that is appropriate to hold both positive and negative offsets from a position in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>number</code> must have addition and multiplication with the type held by the array that is being interpolated.</dd>
<dd>
<code>indexer</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#afd5834e3afad85414bee808e28a49c52">g24_lib::Definitions::default_signed_indexer</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="interpol_8h_source.html#l00056">56</a> of file <a class="el" href="interpol_8h_source.html">interpol.h</a>.</p>

</div>
</div>
<a id="a9cf8114ea148266dfb19a3b571691f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf8114ea148266dfb19a3b571691f57">&#9670;&nbsp;</a></span>interpolate_from_grid_1D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class number , class ArrT , class indexer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::interpolate_from_grid_1D </td>
          <td>(</td>
          <td class="paramtype">const ArrT &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>to_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>to_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>separation</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polynomial interpolation from a unidimensional array (with a number of points). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array of discretized values from which to interpolate.</td></tr>
    <tr><td class="paramname">elem</td><td>The index of the point from which we want to interpolate.</td></tr>
    <tr><td class="paramname">position</td><td>The position at which we want to interpolate expressed as a fraction of the distance between two elements of the array. (<code>-1 &lt; position &lt; 1</code>)</td></tr>
    <tr><td class="paramname">to_left</td><td>Number of points to the left of the point specified by <code>elem</code> to also be considered in the interpolation.</td></tr>
    <tr><td class="paramname">to_right</td><td>Number of points to the right of the point specified by <code>elem</code> to also be considered in the interpolation. <br  />
</td></tr>
    <tr><td class="paramname">separation</td><td>The difference in index between two consecutive elements. (Useful for each unidimensional interpolation in multidimensional grids.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The order of the interpolation will be given by <code>to_left + to_right</code>.</dd>
<dd>
A linear interpolation would be given by <code>to_left = 0</code> and <code>to_right = 1</code> for <code>position &gt; 0</code>, or, equivalently, <code>to_left = 1</code> and <code>to_right = 0</code> for <code>position &lt; 0</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">number</td><td>A type that can hold non-integer numbers. Typically floating point.</td></tr>
    <tr><td class="paramname">indexer</td><td>A type that is appropriate to hold both positive and negative offsets from a position in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>number</code> must have addition and multiplication with the type held by the array that is being interpolated.</dd>
<dd>
<code>indexer</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#afd5834e3afad85414bee808e28a49c52">g24_lib::Definitions::default_signed_indexer</a>.</dd></dl>
<p>The interpolation is performed using Lagrange polynomials. Suppose we will use <img class="formulaInl" alt="$n + 1$" src="form_1.png"/> points, <img class="formulaInl" alt="$x_0, x_1, \ldots, x_n$" src="form_2.png"/>, to perform the interpolation, and that the values of the function at these points are, respectively, <img class="formulaInl" alt="$y_0, y_1, \ldots, y_n$" src="form_3.png"/>. The polynomial at position <img class="formulaInl" alt="$x$" src="form_4.png"/> can be given by: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{j = 0}^n \left (\prod_{k = 0//k \neq j}^{n} \frac{x-x_k}{x_j - x_k} \right ) y_j \]" src="form_5.png"/>
</p>
 
<p class="definition">Definition at line <a class="el" href="interpol_8h_source.html#l00109">109</a> of file <a class="el" href="interpol_8h_source.html">interpol.h</a>.</p>

</div>
</div>
<a id="a27d08a9234a50079bd5d57ad577c436e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d08a9234a50079bd5d57ad577c436e">&#9670;&nbsp;</a></span>laplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tarr , class ndview_like , class cellsizeT , class indexer  = g24_lib::Definitions::default_signed_indexer, class factorT  = g24_lib::Definitions::default_floating_point&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::laplacian </td>
          <td>(</td>
          <td class="paramtype">const Tarr &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ndview_like &amp;&#160;</td>
          <td class="paramname"><em>nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cellsizeT &amp;&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the laplacian of <code>arr</code> at point <code>elem</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is valid both for the (scalar) laplacian of a scalar field and for the (vectorial, component-wise) laplacian of a vector field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array to be differentiated.</td></tr>
    <tr><td class="paramname">elem</td><td>The element of the array where the derivative is meant to be computed.</td></tr>
    <tr><td class="paramname">nd</td><td>The <code><a class="el" href="classg24__lib_1_1ndview.html" title="Allows indexing of multidimensional arrays.">g24_lib::ndview</a></code> that expresses the multidimensional properties of the array.</td></tr>
    <tr><td class="paramname">cs</td><td>The cell size/grid spacing to use.</td></tr>
    <tr><td class="paramname">accuracy</td><td>The accuracy with which to calculate the derivative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>indexer</code> must satisfy the constraints placed on the choice of <a class="el" href="structg24__lib_1_1_definitions.html#afd5834e3afad85414bee808e28a49c52">g24_lib::Definitions::default_signed_indexer</a> (for compatibility with ndview).</dd>
<dd>
<code>factor_type</code> must support multiplications and divisions with itself (and with the elements of the array whose derivatives will be evaluated). It does not need to be a floating point type since the coefficients are stored essentially as rational numbers. </dd></dl>

<p class="definition">Definition at line <a class="el" href="derivatives_8h_source.html#l00373">373</a> of file <a class="el" href="derivatives_8h_source.html">derivatives.h</a>.</p>

</div>
</div>
<a id="a8ab1b220c0489ecf72300d15a97ee2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab1b220c0489ecf72300d15a97ee2f3">&#9670;&nbsp;</a></span>make_butcher_table() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class butcher_final_like &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::make_butcher_table </td>
          <td>(</td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>butcher_final_like</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A specialization for the Euler case. </p>

<p class="definition">Definition at line <a class="el" href="temporal__evolver_8h_source.html#l00539">539</a> of file <a class="el" href="temporal__evolver_8h_source.html">temporal_evolver.h</a>.</p>

</div>
</div>
<a id="a273f68e2c7f9978ff8e08529a4b43f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273f68e2c7f9978ff8e08529a4b43f23">&#9670;&nbsp;</a></span>make_butcher_table() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class butcher_final_like , class ... butcher_entry_likes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::make_butcher_table </td>
          <td>(</td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>butcher_final_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const butcher_entry_likes ...&#160;</td>
          <td class="paramname"><em>entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Butcher tableau from the provided Butcher entries. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">butcher_final_like</td><td>The final entry in the Butcher tableau.</td></tr>
    <tr><td class="paramname">butcher_entry_likes</td><td>The remaining entries in the Butcher tableau. The <code>t = t</code> evaluation is always performed, so the first entry corresponds to the first step after that. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="temporal__evolver_8h_source.html#l00512">512</a> of file <a class="el" href="temporal__evolver_8h_source.html">temporal_evolver.h</a>.</p>

</div>
</div>
<a id="a2f20d929ebd786f26278e241d9cf1e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f20d929ebd786f26278e241d9cf1e95">&#9670;&nbsp;</a></span>make_extended_butcher_table()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class butcher_final_like1 , class butcher_final_like2 , class ... butcher_entry_likes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::make_extended_butcher_table </td>
          <td>(</td>
          <td class="paramtype">const butcher_final_like1&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const butcher_final_like2&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const butcher_entry_likes ...&#160;</td>
          <td class="paramname"><em>entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an extended Butcher tableau from the provided Butcher entries. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">butcher_final_like1</td><td>The first final entry in the extended Butcher tableau.</td></tr>
    <tr><td class="paramname">butcher_final_like2</td><td>The second final entry in the extended Butcher tableau.</td></tr>
    <tr><td class="paramname">butcher_entry_likes</td><td>The remaining entries in the Butcher tableau. The <code>t = t</code> evaluation is always performed, so the first entry corresponds to the first step after that. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="temporal__evolver_8h_source.html#l00529">529</a> of file <a class="el" href="temporal__evolver_8h_source.html">temporal_evolver.h</a>.</p>

</div>
</div>
<a id="ade919fccf337541b1ed0f9384d8c612d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade919fccf337541b1ed0f9384d8c612d">&#9670;&nbsp;</a></span>min_power_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class intg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> intg g24_lib::min_power_2 </td>
          <td>(</td>
          <td class="paramtype">const intg&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the minimum power of 2 larger than or equal to the input. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>intg</code> must be an integer type with bitwise operations.</dd></dl>
<p>Heavily inspired by <a href="https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2">https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2</a> . </p>

<p class="definition">Definition at line <a class="el" href="general__helpers_8h_source.html#l00082">82</a> of file <a class="el" href="general__helpers_8h_source.html">general_helpers.h</a>.</p>

</div>
</div>
<a id="a8fd4763008d09fdd7b9953de2c4c9a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd4763008d09fdd7b9953de2c4c9a91">&#9670;&nbsp;</a></span>raw_read_fspoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer, indexer Size = g24_lib::Definitions::default_fixed_size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classg24__lib_1_1fspoint.html">fspoint</a>&lt;Type, indexer, Size&gt; g24_lib::raw_read_fspoint </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>fspoint</code> read from a stream. </p>
<dl class="section warning"><dt>Warning</dt><dd>Serialization should be handled by textual_input and textual_output. This might still be useful for prompting the user, since it accepts the same formats as <code><a class="el" href="classg24__lib_1_1fspoint.html" title="An array of Size elements of type Type. Mainly to be used as an N-dimensional vector in mathematical ...">g24_lib::fspoint</a>&lt;Type, indexer, Size&gt;::operator&gt;&gt;</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fspoint_8h_source.html#l01462">1462</a> of file <a class="el" href="fspoint_8h_source.html">fspoint.h</a>.</p>

</div>
</div>
<a id="a36900ec737d8ed254b5580d9c146267a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36900ec737d8ed254b5580d9c146267a">&#9670;&nbsp;</a></span>raw_read_point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classg24__lib_1_1point.html">point</a>&lt;Type, indexer&gt; g24_lib::raw_read_point </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">\brief Creates a new `point` read from a stream.

\warning Serialization should be handled by textual_input and textual_output.
         This might still be useful for prompting the user,
         since it accepts the same formats as `g24_lib::point&lt;Type, indexer, Size&gt;::operator&gt;&gt;`.
</pre><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd><code><a class="el" href="classg24__lib_1_1point.html" title="A dynamically sized array of type Type. Mainly to be used as an N-dimensional vector in mathematical ...">g24_lib::point</a></code> is more or less deprecated since its usefulness is limited. In most practical problems, the dimensions are fixed, dynamic allocations are slower and <code>CUDA</code> interoperatability is quite limited. However, compatibility with past projects requires it to remain here for the time being, at least.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">In</td><td>case the size cannot be read properly, uses <a class="el" href="namespaceg24__lib_1_1exceptions.html#a6b5d01ac0547957734140d32e3ff9b5c" title="Exception thrown when an error is encountered during input.">g24_lib::exceptions::throw_exception</a> to possibly throw a <a class="el" href="structg24__lib_1_1exceptions_1_1array__length__misread.html" title="Exception thrown when an input operation cannot determine the array size.">g24_lib::exceptions::array_length_misread</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point_8h_source.html#l01411">1411</a> of file <a class="el" href="point_8h_source.html">point.h</a>.</p>

</div>
</div>
<a id="a92c0b2b14c8f2234aeaae138fbef9dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c0b2b14c8f2234aeaae138fbef9dbc">&#9670;&nbsp;</a></span>raw_read_point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class indexer  = g24_lib::Definitions::default_unsigned_indexer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classg24__lib_1_1point.html">point</a>&lt;Type, indexer&gt; g24_lib::raw_read_point </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const indexer&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">\brief Creates a new `point` read from a stream with a known number of elements.

\warning Serialization should be handled by textual_input and textual_output.
         This might still be useful for prompting the user,
         since it accepts the same formats as `g24_lib::point&lt;Type, indexer, Size&gt;::operator&gt;&gt;`.
</pre><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd><code><a class="el" href="classg24__lib_1_1point.html" title="A dynamically sized array of type Type. Mainly to be used as an N-dimensional vector in mathematical ...">g24_lib::point</a></code> is more or less deprecated since its usefulness is limited. In most practical problems, the dimensions are fixed, dynamic allocations are slower and <code>CUDA</code> interoperatability is quite limited. However, compatibility with past projects requires it to remain here for the time being, at least.</dd></dl>

<p class="definition">Definition at line <a class="el" href="point_8h_source.html#l01442">1442</a> of file <a class="el" href="point_8h_source.html">point.h</a>.</p>

</div>
</div>
<a id="a1fe55b414ae892551fbf319bcba5e388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe55b414ae892551fbf319bcba5e388">&#9670;&nbsp;</a></span>read_comp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt;Type&gt; g24_lib::read_comp </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reduc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a <a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a> from values read from a stream. If <code>reduc</code> is true, if the complex appears to be in the polar form, the argument is read as a fraction of pi. </p>
<p>The possible inputs are: <code>a + i b</code>, <code>a - i b</code>, <code>a + b i</code>, <code>a - bi</code>, <code>b i + a</code>, <code>b i</code>, a, <code>rho cis theta</code>, <code>rho pol theta</code>, ignoring whitespace and capitalization in what regards to the plus or minus signs and the imaginary unit.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Since the standard library already implements <code>std::complex</code>, <code><a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a></code> might be more than a bit superfluous unless <code>CUDA</code> interoperatability is significant... </dd></dl>

<p class="definition">Definition at line <a class="el" href="comp_8h_source.html#l00695">695</a> of file <a class="el" href="comp_8h_source.html">comp.h</a>.</p>

</div>
</div>
<a id="a0795a86f50105085a1f43555e0355553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0795a86f50105085a1f43555e0355553">&#9670;&nbsp;</a></span>read_comp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classg24__lib_1_1comp.html">comp</a>&lt;Type&gt; g24_lib::read_comp </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reduc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a> read from a stream. If <code>reduc</code> is true, if the complex appears to be in the polar form, the argument is read as a fraction of pi. </p>
<p>The possible inputs are: <code>a + i b</code>, <code>a - i b</code>, <code>a + b i</code>, <code>a - bi</code>, <code>b i + a</code>, <code>b i</code>, a, <code>rho cis theta</code>, <code>rho pol theta</code>, ignoring whitespace and capitalization in what regards to the plus or minus signs and the imaginary unit.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Since the standard library already implements <code>std::complex</code>, <code><a class="el" href="classg24__lib_1_1comp.html" title="A complex number.">g24_lib::comp</a></code> might be more than a bit superfluous unless <code>CUDA</code> interoperatability is significant... </dd></dl>

<p class="definition">Definition at line <a class="el" href="comp_8h_source.html#l00673">673</a> of file <a class="el" href="comp_8h_source.html">comp.h</a>.</p>

</div>
</div>
<a id="a502ae08493e867416f5b6dace7cdc892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502ae08493e867416f5b6dace7cdc892">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class Ret  = Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> Ret g24_lib::sign </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Branchlessly gives the sign of something with comparison operators. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Type</code> must have <code>operator &lt;</code>.</dd>
<dd>
<code>Ret</code> must have the signedness of <code>Type</code> (if Type is unsigned, Ret can also be unsigned since the function will only yield non-negative results as well). </dd></dl>

<p class="definition">Definition at line <a class="el" href="general__helpers_8h_source.html#l00106">106</a> of file <a class="el" href="general__helpers_8h_source.html">general_helpers.h</a>.</p>

</div>
</div>
<a id="aedf046e132ed3d55b828a64d6011f359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf046e132ed3d55b828a64d6011f359">&#9670;&nbsp;</a></span>simple_evolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class method , class Func_T , class object , class time_type , class tol_type , class ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> auto g24_lib::simple_evolve </td>
          <td>(</td>
          <td class="paramtype">Func_T &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const time_type &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const time_type &amp;&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tol_type &amp;&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a simpler wrapper for <code><a class="el" href="classg24__lib_1_1temporal__evolver.html" title="Evolves a function in time according to the Runge-Kutta method specified by butcher_tableau.">g24_lib::temporal_evolver</a></code> for objects that are known to be simple to update (i. e., not arrays, so something like a scalar or a vector function). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">method</td><td>The Runge-Kutta method (extended or not) with which to perform the evolution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Calculates the derivative of the function being advanced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>f</code> must take as arguments: A <b>non-const</b> reference to the <code>object</code> where the derivative is to be stored (A const reference to) the current value of the function, which, given that <code><a class="el" href="namespaceg24__lib.html#ade6ba1f821989a3d8d4523af275bd9c1" title="Defers the evaluation of most overloadable operators on x.">g24_lib::defer</a></code> is used, should be templated (thus, we cannot use a plain old function, but must use a functor with a templated <code>operator()</code> or a generic lambda) (A const reference to) the current time (A const reference to) the current timestep The extra arguments specified in <code>params</code> (with any desired combination of constness and references, since the internal functions use perfect forwarding).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The current value of the function.</td></tr>
    <tr><td class="paramname">current</td><td>The current time.</td></tr>
    <tr><td class="paramname">dt</td><td>The timestep to advance the function.</td></tr>
    <tr><td class="paramname">tol</td><td>The tolerance to be used in <code>update</code> (mainly for adaptive methods, where it is used to regulate the estimation of the next timestep).</td></tr>
    <tr><td class="paramname">params</td><td>Extra parameters to be passed to <code>f</code> and <code>update</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structg24__lib_1_1simple__evolve__result.html" title="The results of a g24_lib::simple_evolve.">g24_lib::simple_evolve_result</a></code> of appropriate types.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classg24__lib_1_1temporal__evolver.html#a26d0b914c0bdc326ed918dbff5ebe339" title="Calculates a timestep according to the Runge-Kutta method specified by butcher_tableau.">g24_lib::temporal_evolver::evolve</a></code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="temporal__evolver_8h_source.html#l01099">1099</a> of file <a class="el" href="temporal__evolver_8h_source.html">temporal_evolver.h</a>.</p>

</div>
</div>
<a id="a4060743265c190dc087fb153c318cdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4060743265c190dc087fb153c318cdf6">&#9670;&nbsp;</a></span>stand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="preliminary__macros_8h.html#a8c37743605cf5a7b3fcf1013712ba192">CUDA_HOS_DEV</a> Type g24_lib::stand </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Branchlessly clamps something to <img class="formulaInl" alt="$\left ]-1,1\right]$" src="form_0.png"/>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Type</code> must have <code>operator *</code> with <code>double</code>.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>This is included only for compatibility with <a class="el" href="classg24__lib_1_1comp.html">comp</a>, which is itself deprecated. The function does not conform to the same standard of generality and performance as the rest of the library.</dd></dl>

<p class="definition">Definition at line <a class="el" href="general__helpers_8h_source.html#l00121">121</a> of file <a class="el" href="general__helpers_8h_source.html">general_helpers.h</a>.</p>

</div>
</div>
<a id="a715568c02201d4d5d8f41e3ed8ae647d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715568c02201d4d5d8f41e3ed8ae647d">&#9670;&nbsp;</a></span>textual_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void g24_lib::textual_input </td>
          <td>(</td>
          <td class="paramtype">stream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inputs an object in text mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the object being input.</td></tr>
    <tr><td class="paramname">stream</td><td>Something akin to an <code>istream</code>, from which text can be input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">In</td><td>case an input error is encountered, uses <a class="el" href="namespaceg24__lib_1_1exceptions.html#a6b5d01ac0547957734140d32e3ff9b5c" title="Exception thrown when an error is encountered during input.">g24_lib::exceptions::throw_exception</a> to possibly throw a <a class="el" href="structg24__lib_1_1exceptions_1_1input__error.html" title="Exception thrown when an error is encountered during input.">g24_lib::exceptions::input_error</a>. The input object <code>in</code> may be in an invalid state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The behaviour of this function for user defined classes may be more simply "overloaded" by providing a <code>textual_input</code> member function that takes <code>s</code> as argument, which will be used whenever available.</dd>
<dd>
For classes that implement an <code>operator &gt;&gt;</code> that applies to an object of type <code>stream</code>, that operator is used.</dd>
<dd>
For classes that do not have either a <code>textual_input</code> member function or an <code>operator &gt;&gt;</code> that applies to an object of type <code>stream</code>, a <code><a class="el" href="structg24__lib_1_1flat__imitation__struct.html" title="Constructs a struct that has every scalar member of all the members of a class (at all levels of incl...">g24_lib::flat_imitation_struct</a></code> is constructed, every member is input from the stream and the new value of <code>in</code> will come from a new <code>T</code> constructed from the imitation struct.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>stream</code> must have a valid <code>operator &gt;&gt;</code> with any type that satisfies <code>std::is_scalar</code> (bools, integers, floating point types, enums or pointers). </dd></dl>

<p class="definition">Definition at line <a class="el" href="serialization__helpers_8h_source.html#l00246">246</a> of file <a class="el" href="serialization__helpers_8h_source.html">serialization_helpers.h</a>.</p>

</div>
</div>
<a id="a0d3886bf5ea73ba62b0da62535a5fd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3886bf5ea73ba62b0da62535a5fd1f">&#9670;&nbsp;</a></span>textual_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class stream , class str  = std::basic_string&lt;typename stream::char_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void g24_lib::textual_output </td>
          <td>(</td>
          <td class="paramtype">stream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const str &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs an object in text mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the object being output.</td></tr>
    <tr><td class="paramname">stream</td><td>Something akin to an <code>ostream</code>, to which text can be output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A set of characters (of appropriate type) that may be outputted to separate the several members of a reflected struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">In</td><td>case an output error is encountered, uses <a class="el" href="namespaceg24__lib_1_1exceptions.html#a6b5d01ac0547957734140d32e3ff9b5c" title="Exception thrown when an error is encountered during input.">g24_lib::exceptions::throw_exception</a> to possibly throw a <a class="el" href="structg24__lib_1_1exceptions_1_1output__error.html" title="Exception thrown when an error is encountered during output.">g24_lib::exceptions::output_error</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The behaviour of this function for user defined classes may be more simply "overloaded" by providing a <code>textual_output</code> member function that takes <code>s</code> and <code>separator</code> as arguments, which will be used whenever available.</dd>
<dd>
For classes that implement an <code>operator &lt;&lt;</code> that applies to an object of type <code>stream</code>, that operator is used.</dd>
<dd>
For classes that do not have either a <code>textual_output</code> member function or an <code>operator &lt;&lt;</code> that applies to an object of type <code>stream</code>, a <code><a class="el" href="structg24__lib_1_1flat__imitation__struct.html" title="Constructs a struct that has every scalar member of all the members of a class (at all levels of incl...">g24_lib::flat_imitation_struct</a></code> is constructed and every member is output to the stream.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>stream</code> must have a valid <code>operator &lt;&lt;</code> with any type that satisfies <code>std::is_scalar</code> (bools, integers, floating point types, enums or pointers). </dd></dl>

<p class="definition">Definition at line <a class="el" href="serialization__helpers_8h_source.html#l00190">190</a> of file <a class="el" href="serialization__helpers_8h_source.html">serialization_helpers.h</a>.</p>

</div>
</div>
<a id="a55cd110ba53c6a6a51bced0cf1fac427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cd110ba53c6a6a51bced0cf1fac427">&#9670;&nbsp;</a></span>to_CUDA() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto g24_lib::to_CUDA </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a form of <code>obj</code> that is suitable to be operated on in a <code>CUDA</code> kernel. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This will work with any class that has defined a <code><a class="el" href="namespaceg24__lib.html#a55cd110ba53c6a6a51bced0cf1fac427" title="Provides a form of obj that is suitable to be operated on in a CUDA kernel.">to_CUDA()</a></code> method. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_c_u_d_a__utilities_8h_source.html#l00101">101</a> of file <a class="el" href="_c_u_d_a__utilities_8h_source.html">CUDA_utilities.h</a>.</p>

</div>
</div>
<a id="a82ffda1c518ace10422843a0636ed26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ffda1c518ace10422843a0636ed26a">&#9670;&nbsp;</a></span>to_CUDA() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto g24_lib::to_CUDA </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a form of <code>obj</code> that is suitable to be operated on in a <code>CUDA</code> kernel. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This will work with any class that has defined a <code><a class="el" href="namespaceg24__lib.html#a55cd110ba53c6a6a51bced0cf1fac427" title="Provides a form of obj that is suitable to be operated on in a CUDA kernel.">to_CUDA()</a></code> method. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_c_u_d_a__utilities_8h_source.html#l00123">123</a> of file <a class="el" href="_c_u_d_a__utilities_8h_source.html">CUDA_utilities.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9a4b8433b4294030c0182cf59731e3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4b8433b4294030c0182cf59731e3c0">&#9670;&nbsp;</a></span>is_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool g24_lib::is_container = !(std::is_void_v&lt;<a class="el" href="namespaceg24__lib.html#a50a0cf1c5325fb5405f215e22c8bdde4">indexer_type</a>&lt;C&gt;&gt; || std::is_void_v&lt;<a class="el" href="namespaceg24__lib.html#a90b455b207b88a2b2fad31a2bd9f0ab4">value_type</a>&lt;C&gt;&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>C</code> is a valid container for the purposes of this library. </p>
<p>A valid container will have both non-void <code><a class="el" href="namespaceg24__lib.html#a50a0cf1c5325fb5405f215e22c8bdde4" title="Yields the indexer type of a container-like class, or void if the class isn&#39;t a container.">g24_lib::indexer_type</a></code> and <code><a class="el" href="namespaceg24__lib.html#a90b455b207b88a2b2fad31a2bd9f0ab4" title="Yields the value type of a container-like class, or void if the class isn&#39;t a container.">g24_lib::value_type</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespaceg24__lib.html#a50a0cf1c5325fb5405f215e22c8bdde4" title="Yields the indexer type of a container-like class, or void if the class isn&#39;t a container.">g24_lib::indexer_type</a></code>, <code><a class="el" href="namespaceg24__lib.html#a90b455b207b88a2b2fad31a2bd9f0ab4" title="Yields the value type of a container-like class, or void if the class isn&#39;t a container.">g24_lib::value_type</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="general__helpers_8h_source.html#l00376">376</a> of file <a class="el" href="general__helpers_8h_source.html">general_helpers.h</a>.</p>

</div>
</div>
<a id="a8db548d9ef3d2229f62c56b98e010c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db548d9ef3d2229f62c56b98e010c61">&#9670;&nbsp;</a></span>is_deferred</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool g24_lib::is_deferred = std::is_base_of_v&lt;internals::deferred_base,std::decay_t&lt;C&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>C</code> expresses a type on which the operations are deferred. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespaceg24__lib.html#ade6ba1f821989a3d8d4523af275bd9c1" title="Defers the evaluation of most overloadable operators on x.">g24_lib::defer</a></code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="deferred__ops_8h_source.html#l00043">43</a> of file <a class="el" href="deferred__ops_8h_source.html">deferred_ops.h</a>.</p>

</div>
</div>
<a id="ac83d4e45695ca05e650e70bfc607d0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83d4e45695ca05e650e70bfc607d0fc">&#9670;&nbsp;</a></span>is_memory_context</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class context &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool g24_lib::is_memory_context = std::is_base_of_v&lt;<a class="el" href="structg24__lib_1_1_memory_context_1_1memory__context__base.html">MemoryContext::memory_context_base</a>, context&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>context</code> is a valid memory context. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Valid memory contexts are classes that derive from <code><a class="el" href="structg24__lib_1_1_memory_context_1_1memory__context__base.html" title="Provides a base class for all memory contexts.">g24_lib::MemoryContext::memory_context_base</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory__manager_8h_source.html#l00075">75</a> of file <a class="el" href="memory__manager_8h_source.html">memory_manager.h</a>.</p>

</div>
</div>
<a id="aa8e15eae43038dedad37a817fd3c4fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e15eae43038dedad37a817fd3c4fb2">&#9670;&nbsp;</a></span>is_memory_manager</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class manager &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool g24_lib::is_memory_manager = internals::memory_manager_checker&lt;manager&gt;::is_manager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>manager</code> is a valid memory manager. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Valid memory managers are classes that derive from <code><a class="el" href="structg24__lib_1_1memory__manager__base.html" title="Provides a base class for all memory managers.">g24_lib::memory_manager_base</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory__manager_8h_source.html#l00268">268</a> of file <a class="el" href="memory__manager_8h_source.html">memory_manager.h</a>.</p>

</div>
</div>
<a id="a26cb719a58a528fd6413386435a5eb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cb719a58a528fd6413386435a5eb6b">&#9670;&nbsp;</a></span>is_parallelism</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class parallel &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool g24_lib::is_parallelism = std::is_base_of_v&lt;<a class="el" href="structg24__lib_1_1_parallelism_1_1parallelism__base.html">Parallelism::parallelism_base</a>, parallel&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>parallel</code> is a valid form of parallelism. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Valid forms of parallelism are classes that derive from <code>g24_lib::parallelism::parallelism_base</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parallelism_8h_source.html#l01526">1526</a> of file <a class="el" href="parallelism_8h_source.html">parallelism.h</a>.</p>

</div>
</div>
<a id="afe4c4414ad6148853a74bab54d4133e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4c4414ad6148853a74bab54d4133e7">&#9670;&nbsp;</a></span>pi</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T g24_lib::pi</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= T{3.1415926535897932384626433832795028841971693993751058209749445923078164</div>
<div class="line">06286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105</div>
<div class="line">55964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339</div>
<div class="line">36072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519</div>
<div class="line">415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624L}</div>
</div><!-- fragment -->
<p>An object of type <code>T</code> holding the value of pi. Precision assured up to 512 decimal places, assuming the type supports it, otherwise rounded to the appropriate precision... </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type.</td></tr>
  </table>
  </dd>
</dl>
<p>The 512 decimal places of pi were taken from <a href="https://www.piday.org/million/">https://www.piday.org/million/</a> .</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>T</code> must be constructible from a long double. (Will update for larger precision if future standards include it.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="general__helpers_8h_source.html#l00042">42</a> of file <a class="el" href="general__helpers_8h_source.html">general_helpers.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespaceg24__lib_html_a5517c8b80dd7e62bc9d9154ca766bcbe"><div class="ttname"><a href="namespaceg24__lib.html#a5517c8b80dd7e62bc9d9154ca766bcbe">g24_lib::butcher_entry</a></div><div class="ttdeci">constexpr CUDA_HOS_DEV auto butcher_entry(const constexpr_fraction&lt; factorT, num, denom &gt; eval_t, const frac_gens ... fracs)</div><div class="ttdef"><b>Definition:</b> <a href="temporal__evolver_8h_source.html#l00474">temporal_evolver.h:474</a></div></div>
<div class="ttc" id="anamespaceg24__lib_1_1_runge_kutta_methods_html_add32e2f78720bc709db9f86c9ddf64d5"><div class="ttname"><a href="namespaceg24__lib_1_1_runge_kutta_methods.html#add32e2f78720bc709db9f86c9ddf64d5">g24_lib::RungeKuttaMethods::frac</a></div><div class="ttdeci">constexpr_fraction&lt; Factor, num, denom &gt; frac</div><div class="ttdoc">A simple shorthand notation to ease the writing of the tables.</div><div class="ttdef"><b>Definition:</b> <a href="temporal__evolver_8h_source.html#l01118">temporal_evolver.h:1118</a></div></div>
<div class="ttc" id="astructg24__lib_1_1constexpr__fraction_html"><div class="ttname"><a href="structg24__lib_1_1constexpr__fraction.html">g24_lib::constexpr_fraction</a></div><div class="ttdoc">A constexpr way of holding a compile time fraction.</div><div class="ttdef"><b>Definition:</b> <a href="temporal__evolver_8h_source.html#l00106">temporal_evolver.h:107</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceg24__lib.html">g24_lib</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
