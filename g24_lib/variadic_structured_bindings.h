#ifndef G24_LIB_VAR_S_B
#define G24_LIB_VAR_S_B

/**********************************************
 *                                            *
 *  BIBLIOTECA DE FUNÇÕES MULTI-DIMENSIONAIS  *
 *                                            *
 *     Por: Gonçalo Vaz (87321)               *
 *          Nuno Fernandes (87342)            *
 *     [Antigo Grupo 24 de FC 2017-2018]      *
 * [Antigo Grupo 25 de Programação 2016-2017] *
 *                                            *
 **********************************************/

/*!

\file variadic_structured_bindings.h

\brief Internal definition of a series of structures that allow for
       a limited form of "variadic" structured bindings.

\remark Depending on the users' settings, this file either includes an auto-generated
        `var_s_b_out.h` or uses preprocessor-time cycles defined in Mad<ro Trid<s
        (by the same author) to generate a number of template specializations
        that can be specified through `G24_LIB_VARIADIC_STRUCTURED_BINDINGS_SIZE`.

This file is almost entirely automatically generated using a simple C++ script.

\author Nuno Fernandes (main coder, current maintainer)

*/

namespace g24_lib
{

namespace internals
{
///\cond HIDDEN_SYMBOLS

template <class T> struct variadic_structured_binding<T, 1>
{
  CUDA_HOS_DEV static auto struct_to_nested(const T &s)
  {
    if constexpr (std::is_scalar_v<T>)
    {
      nested_imitation_struct<T> ret;
      ret.template get_element<1>() = s;
      return ret;
    }
    else
    {
      auto [ a0    ] = s;
      nested_imitation_struct<T> ret;
      ret.template get<0>() = a0;
      return ret;
    }
  }
};

#ifdef G24_LIB_VARIADIC_STRUCTURED_BINDINGS_SIZE

#ifndef MACKRO_TRICKS
#define G24_LIB_INCLUDED_TRICKS 1

#include "mackro_tricks.h"
//Just a bit of macro magic for preprocessing-time cycles.

#endif

#if MACKRO_EVAL(MACKRO_IS_GREATER(G24_LIB_VARIADIC_STRUCTURED_BINDINGS_SIZE, (0,0,0,0,0,0,0,1)))

//Since the autogenerated file has variadic structured bindings up to 128 members,
//if the user specifies that as a maximum value, it's easier/faster to just include the file.

#define G24_LIB_VAR_S_B_HELPER_1(IGNORE, NUM) , MACKRO_NUM_TO_TOKEN(NUM)

#define G24_LIB_VAR_S_B_HELPER_2(IGNORE, NUM) \
ret.template get <MACKRO_NUM_TO_VALUE(NUM)>() = MACKRO_NUM_TO_TOKEN(NUM);

#define G24_LIB_VAR_S_B_MAKER(IGNORE, NUM)               \
template <class T> struct                                \
variadic_structured_binding<T, MACKRO_NUM_TO_VALUE(NUM)> \
{                                                        \
CUDA_HOS_DEV static auto struct_to_nested(const T &s)    \
{                                                        \
auto [ x1 MACKRO_CYCLE(G24_LIB_VAR_S_B_HELPER_1, 0, (0,1), (1), NUM) ] = s; \
nested_imitation_struct<T> ret;                          \
MACKRO_CYCLE(G24_LIB_VAR_S_B_HELPER_2, 0, (1), (1), NUM) \
return ret;                                              \
}                                                        \
};                                                       \

MACKRO_EVAL(MACKRO_EVAL(MACKRO_CYCLE(G24_LIB_VAR_S_B_MAKER, 0, (0,1), (1), G24_LIB_VARIADIC_STRUCTURED_BINDINGS_SIZE)))

//In case strange things begin to appear, pile another MACKRO_EVAL in here.
//If they persist, add another. Still? Another. Got the point? Good.

//In essence, these MACKRO_EVALs force the preprocessor to expand the macros within the cycle,
//and, with large enough values of G24_LIB_VARIADIC_STRUCTURED_BINDINGS_SIZE,
//more expansions may be needed to get the desired output...

#undef G24_LIB_VAR_S_B_MAKER
#undef G24_LIB_VAR_S_B_HELPER_2
#undef G24_LIB_VAR_S_B_HELPER_1

#else

#include "varsb.h"

#endif


#ifdef G24_LIB_INCLUDED_TRICKS

#if G24_LIB_CLEAN_UP_MACROS
#include "mackro_tricks_undef.h"

#undef G24_LIB_INCLUDED_TRICKS

#endif

#endif

#else

#include "varsb.h"

#endif

///\endcond
}


}
#endif